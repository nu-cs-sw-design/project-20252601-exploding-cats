@startuml

' NEXT BIG STEPS:
' update constructor args as needed
' add any instance variables each new class would need to fulfill functionality
' add in the methods (and make sure accounting for all fields/functs of original design)
' make sure i've updated all the class relationships/arrows
' dive deeper into things like access modifiers, design principles, etc

package ui {
    +class Main {
        +{static} main(String[] args): void
    }

    +class GameUI {
        -messages: ResourceBundle
        -gameType: GameType
        -numPlayers: numPlayers
        -gameLoader: GameLoader

        +GameUI()
        +promptForGameSetup(gameLoader: GameLoader): void
        -promptForLanguage(): void
        -promptForGameType(): void
        -promptForNumberOfPlayers(): int
        ' PLAN: GameUI will call GameLoader#setupGame() and will initialize any other necessary classes
        ' PLAN: to get the game started here, which will include passing in the ResourceBundle to other UI classes,
        ' PLAN: as well as passing in the game type and player number into domain-level classes
        ' PLAN: startGame will end with calling TurnLogicUI#startTurn
        +startGame(): void
    }

    +class InputValidator {
        -numPlayers: int
        -gameType: GameType

        +InputValidator(numPlayers: int)
        -checkValidPlayerIndexInput(): int
        -checkUserWithinBounds(userIndex: int): boolean
        -checkCardWithinBounds(cardIndex: int, player: Player): boolean
        -checkNegativeIndexDeck(indexToInsert: int): boolean
        -checkIfGreaterThanMaxIndexDeck(indexToInsert: int): boolean
        -checkCardIfInvalid(card: Card): boolean
    }

    +class TurnLogicUI {
        -inputValidator: InputValidator
        -messages: ResourceBundle
        -numPlayers: int
        -turnOrder: TurnOrder
        -CardLogicUI: CardLogicUI

        ' PLAN: TurnLogicUI instantiates the TurnOrder and CardLogicUI
        +TurnLogicUI(inputValidator: InputValidator, messages: ResourceBundle, numPlayers: int)
        ' PLAN: incorporate logic from printPlayerTurn into startTurn, if possible
        +startTurn(): void
        'NOTE: promptForEndTurn was previously called checkIfTheyEndTurn
        -promptForTurnEnd(): boolean
        -endTurn(): boolean
        -checkIfGameOver(): boolean
        -endGame(): void
    }

    +class CardLogicUI {
        -{final} commandFactory: SimpleCardCommandFactory
        -{final} gameInvoker: GameInvoker
        -{final} inputValidator: InputValidator

        +CardLogicUI(commandFactory, gameInvoker, inputValidator)

        ' PLAN: playCard() will call the user for the desired inputs, take that input in
        ' PLAN: then, based on the CardType, will call the commandFactory's createCommand with
        ' PLAN: any necessary args, and then will call the invoker to execute that CommandType
        ' PLAN: The goal here is to abstract the need to have so many different card-specific 'play' methods
        +playCard(CardType card): void
        ' PLAN: will prompt the user for the desired inputs based on the card's InputType
        -promptPlayerForInputType(CardType card): void
    }
}
Main..>ui.GameUI
Main..>domain.GameLoader

GameUI-->java.ResourceBundle
GameUI-->domain.GameLoader
GameUI-->domain.GameType
GameUI..>ui.TurnLogicUI

TurnLogicUI-->java.ResourceBundle
TurnLogicUI-->domain.TurnOrder
TurnLogicUI-->ui.CardLogicUI

CardLogicUI-->domain.SimpleCardCommandFactory
CardLogicUI-->domain.GameInvoker
CardLogicUI..>domain.CardType

'TODO: come back to these relationships for InputValidation to best match design principles
InputValidator-->domain.GameType
GameUI..>ui.InputValidator
TurnLogicUI-->ui.InputValidator
CardLogicUI-->ui.InputValidator

package domain {
    +class GameLoader {
        -deck: Deck

        +GameLoader()
        +setUpGame()
        -instantiateDeck()
        -instantiateDeckActionCommands()
        -instantiateTurnOrder()
        -instantiateTurnActionCommands()
    }

    +class GameInvoker {
        -commands: List<Command>

        +GameInvoker()
        +addCommand(command: Command): void
        +executeCommands(): void
    }

    interface Receiver {
        +executeActionCorrespondingToCardType(cardType: CardType)
    }

    +class SimpleCardCommandFactory() {
        -deck: Deck
        -turnOrder: List<PlayerID>

        +CardCommandFactory()
        ' TODO: may need to adjust this if it's necessary to pass in the user input here (2 types of it: playerID vs int)
        ' TODO: will also need to look into if any cards require more than 1 type of input (which i believe they do)
        ' NOTE: getCommandForCardType will instantiate and return a Command corresponding to the CardType
        ' NOTE: there are less Commands than CardTypes because some share functionalities, like how CAT_ONE and CAT_TWO
        +getCommandForCardType(cardType: CardType, arguments): Command
        -getCommandForNoInputCard(cardType: CardType): Command
        -getCommandForPlayerInputCard(cardType: CardType, targetPlayer: PlayerID): Command
        -getCommandForIndexInputCard(cardType: CardType, targetIndex: int): Command
    }

    +interface Command {
        +execute(): void
        +undo(): void
    }

    +abstract class ReversibleCommand {
        +execute(): void
        +undo(): void
    }

    +abstract class IrreversibleCommand {
        +execute(): void
        +{final} undo(): void
    }

    note right of IrreversibleCommand
        The final undo() method in IrreversibleCommand would be a
        concrete method throwing an UnsupportedOperationException.
    end note

    +class ShuffleDeckCommand {
        -deck: Deck

        +ShuffleDeckCommand(deck: Deck)
        +execute(): void
    }

    +class SeeTheFutureCommand {
        -deck: Deck
        -timesFive: boolean

        ' NOTE: if timesFive is true, then sees 5 cards into the future (expansion pack version)
        ' NOTE: if timeFives is false, then 3 cards into the future (original version)
        +SeeTheFutureCommand(deck: Deck, timesFive: boolean)
        +execute(): void
        +undo(): void
    }

    +class SwapTopAndBottomCardCommand {
        -deck: Deck

        +SwapTopAndBottomCardCommand(deck: Deck)
        +execute(): void
        +undo(): void
    }

    +class DrawBottomCardCommand {
        -deck: Deck
        -playerHand: PlayerHand

        +DrawBottomCardCommand(deck: Deck, playerHand: PlayerHand)
        +execute(): void
        +undo(): void
    }

    +class DefuseCommand {
        -deck: Deck

        +DefuseCommand(deck: Deck)
        +execute(): void
    }

    +class NopeCommand {
        +NopeCommand()

        +execute(): void
        +undo(): void
    }

     +class SkipTurnCommand {
        -turnOrder: List<PlayerID>
        -isSuper: boolean

        +SkipTurnCommand(turnOrder: List<PlayerID>, isSuper: boolean)
        +execute(): void
        +undo(): void
    }

    +class ReverseTurnOrderCommand {
        -turnOrder: List<PlayerID>

        +SkipTurnCommand(turnOrder: List<PlayerID>)
        +execute(): void
        +undo(): void
    }

    +class AttackPlayerCommand {
        -turnOrder: List<PlayerID>

        +AttackCommand(turnOrder: List<PlayerID>)
        +execute(): void
        +undo(): void
    }

    +abstract class PlayerHandCommand {
        +execute(): void
        +undo(): void
    }

    +class FlipImplodeFaceUpCommand {
        -playerHand: PlayerHand

        +FlipImplodeFaceUpCommand()
        +execute(): void
    }

    +class ExplodeCommand {
        +ExplodeCommand()
        +execute(): void
    }

    ' TODO: go into the commands later to flesh out any args they need to be functional
    ' QUESTION: how accurate and functionally correct do I need to be with the specifics of each of these cards
    ' QUESTION: in my design, as I'm likely to miss some details since I didn't have to write use cases for all of these?
    +class CursePlayerCommand {
        -targetPlayer: playerID

        +CursePlayerCommand(targetPlayer: playerID)
        +execute(): void
        +undo(): void
    }

    +class MarkCardCommand {
        -targetPlayer: PlayerID
        -targetCardIndex: int

        ' TODO: if more secure, could also use CardType here instead of cardIndex and loop through targetPlayer's hand
        +MarkCardCommand(targetPlayer: playerID, targetCardIndex: int)
        +execute(): void
        +undo(): void
    }

    +class StealRandomCardCommand {
        -targetPlayer: PlayerID

        +StealRandomCardCommand(targetPlayer: playerID)
        +execute(): void
        +undo(): void
    }

    +class PlayerHand {
        +playerID: PlayerID
        -hand: List<Card>

        +PlayerHand()

        -addCardToHand(card: Card): void
        -removeCardFromHand(playerIndex: int, cardType: CardType): void
        +getIndexOfCardFromHand(playerIndex: int, cardType: CardType): int

        +playDefuse(idxToInsertExplodingKitten: int, playerIndex: int): void
        +playCatomicBomb(): void
        +playReverse(): void
        +playSkip(superSkip: boolean): int
        +playGarbageCollection(cardToDiscard: CardType)
        +playMark(playerIndex: int, cardIndex: int): void
        +playTargetedAttack(attackedPlayerIndex: int): void
        'QUESTION: in what cases are the following two methods used, and do I need to keep them?
        +playExplodingKitten(playerIndex: int): boolean
        +playImplodingKitten(): void

        +stealRandomCardFromPlayer(player: Player): void
        +stealSpecificCardFromPlayer(cardType: CardType, player: PlayerID): void
        +attackPlayer(player: Player): void

        -checkPlayerHandEmpty(player: Player): boolean
        +checkIfPlayerDead(playerIndex: int): boolean
        +checkIfPlayerHasCard(playerIndex: int, cardType: CardType): boolean
    }

    +class TurnOrder {
        -numPlayers: int
        -activePlayer: PlayerID
        -turnOrder: List<PlayerID>

        +TurnOrder(numPlayers: int)
        +executeActionCorrespondingToCardType(cardType: CardType)
        -selectRandomPlayer(): PlayerID
        -incrementPlayerTurn(): void
        -decrementNumberOfTurns(): void
        -setCurrentPlayerTurn(turn: int): void
    }

    +class Deck {
        -deck: List<Card>

        +Deck()
        +executeActionCorrespondingToCardType(cardType: CardType)
        -drawCardFromTop(): Card
        -drawCardFromBottom(): Card
        -swapTopAndBottomCards(): void
        -shuffleDeck(): void
        -peekTopThreeCards(): List<Card>
        -peekTopFiveCards(): List<Card>
        -insertCards(cardType: CardType, numberOfCards: int, bottom: boolean): void
        -insertExplodingKittenAtIndex(index: int): void
        -insertImplodingKittenAtIndex(index: int): void
    }

    ' TODO: I moved attack logic into this class but I need to go back and
    ' TODO (continued): to figure out how to connect this / where to rest of design based on use cases
    +class AttackQueue() {
        -List<Integer> attackQueue;
        -int attackCounter;
        -int numberOfAttacks;
        -boolean attacked;

        +startAttackPhase(): void
        +incrementAttackCounter(): void
        +setAttackCounter(playerIndex: int): void
        +addAttacks(): void
        +addAttackQueue(attack: int): void
        +removeAttackQueue(): int
        +isAttackQueueEmpty(): boolean
        +getAttacked(): boolean
        +getAttackCounter(): int
        +getNumberOfAttacks(): int
        ~setNumberOfAttacks(numberOfAttacks: int): void
        ~setAttacked(attacked: boolean): void
    }

    +class Card {
        -cardType: CardType
        -isMarked: boolean
        -isFaceUp: boolean

        +Card(cardType: CardType)
    }

    +enum CardType {
        NOPE,
        DEFUSE,
        ATTACK,
        SHUFFLE,
        SKIP,
        SEE_THE_FUTURE,
        CAT_ONE,
        CAT_TWO,
        CAT_THREE,
        CAT_FOUR,
        EXPLODING_KITTEN,
        STREAKING_KITTEN,
        SWAP_TOP_AND_BOTTOM,
        GARBAGE_COLLECTION,
        CURSE_OF_THE_CAT_BUTT,
        ALTER_THE_FUTURE,
        CATOMIC_BOMB,
        SUPER_SKIP,
        MARK,
        IMPLODING_KITTEN,
        REVERSE,
        FERAL_CAT,
        TARGETED_ATTACK,
        DRAW_FROM_THE_BOTTOM

        -{final} gameType: GameType
        -{final} inputType: InputType

        +CardType(gameType: GameType)
        +hasMatchingGameType(otherCardType: CardType): boolean
        +isInputType(inputType: InputType): boolean
    }

    +enum GameType {
        NONE,
        EXPLODING_KITTENS,
        STREAKING_KITTENS,
        IMPLODING_KITTENS
    }

    +enum InputType {
        NO_INPUT,
        PLAYER_ID_INPUT,
        INDEX_INPUT
    }

    +enum PlayerID {
        PLAYER_ONE,
        PLAYER_TWO,
        PLAYER_THREE,
        PLAYER_FOUR,
        PLAYER_FIVE
    }

    ' List of command for reference
    'ShuffleDeckCommand
    'SeeTheFutureCommand
    'SwapTopAndBottomCardCommand
    'DrawBottomCardCommand
    'DefuseCommand
    'NopeCommand
    'SkipTurnCommand
    'ReverseTurnOrderCommand
    'AttackPlayerCommand
    'ImplodeCommand
    'ExplodeCommand
    'CursePlayerCommand
    'MarkCardCommand
    'StealRandomCardCommand

    GameLoader..>Deck

    GameInvoker-->"*"Command
    GameInvoker-->"*"PlayerHand

    SimpleCardCommandFactory-->Deck
    SimpleCardCommandFactory-->"*"PlayerID



    ReversibleCommand..|>Command
    IrreversibleCommand..|>Command

    ShuffleDeckCommand--|>ReversibleCommand
    SeeTheFutureCommand--|>ReversibleCommand
    SwapTopAndBottomCardCommand--|>ReversibleCommand
    DrawBottomCardCommand--|>IrreversibleCommand
    DrawTopCardCommand--|>IrreversibleCommand
    DefuseCommand--|>IrreversibleCommand
    NopeCommand--|>ReversibleCommand
    SkipTurnCommand--|>ReversibleCommand
    ReverseTurnOrderCommand--|>ReversibleCommand
    AttackPlayerCommand--|>ReversibleCommand
    FlipImplodeFaceUpCommand--|>IrreversibleCommand
    ExplodeCommand--|>IrreversibleCommand
    CursePlayerCommand--|>ReversibleCommand
    MarkCardCommand--|>ReversibleCommand
    StealRandomCardCommand--|>ReversibleCommand

    TurnOrder--|>Receiver
    Deck--|>Receiver
    PlayerHand--|>Receiver

    ShuffleDeckCommand-->Deck
    DefuseCommand-->Deck

    Deck-u->"*"Card
    Card-->CardType
    CardType-->GameType
    CardType-->InputType


    PlayerHand-->PlayerID
}

package java {
    +class Scanner {
    }

    +abstract class ResourceBundle {
    }

    +class Random {
    }
}

@enduml