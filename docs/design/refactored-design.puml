@startuml

' NEXT BIG STEPS:
' update instance variables and constructor args as needed to be fully functional
' add in any methods I missed that are needed for functionality
' make sure i've updated all the class relationships/arrows
' dive deeper into things like access modifiers, design principles, etc

package ui {
    +class Main {
        +{static} main(String[] args): void
    }

    +class GameUI {
        -messages: ResourceBundle
        -gameType: GameType
        -numPlayers: numPlayers
        -gameLoader: GameLoader
        -scanner: Scanner

        +GameUI()
        +promptForGameSetup(gameLoader: GameLoader): void
        -promptForLanguage(): void
        -promptForGameType(): void
        -promptForNumberOfPlayers(): int
        ' PLAN: GameUI will call GameLoader#setupGame() and will initialize any other necessary classes
        ' PLAN: to get the game started here, which will include passing in the ResourceBundle to other UI classes,
        ' PLAN: as well as passing in the game type and player number into domain-level classes
        ' PLAN: startGame will end with calling TurnLogicUI#startTurn
        +startGame(): void
    }

    +class InputValidator {
        -numPlayers: int
        -gameType: GameType

        +InputValidator(numPlayers: int)
        -checkValidPlayerIndexInput(): int
        -checkUserWithinBounds(userIndex: int): boolean
        -checkCardWithinBounds(cardIndex: int, player: Player): boolean
        -checkNegativeIndexDeck(indexToInsert: int): boolean
        -checkIfGreaterThanMaxIndexDeck(indexToInsert: int): boolean
        -checkCardIfInvalid(card: Card): boolean
    }

    +class TurnLogicUI {
        -inputValidator: InputValidator
        -messages: ResourceBundle
        -numPlayers: int
        -turnOrder: TurnOrder
        -CardLogicUI: CardLogicUI
        ' QUESTION: is it okay for each UI class to instantiate its own Scanner as needed (whether as instance or locally)?
        -scanner: Scanner

        ' PLAN: TurnLogicUI instantiates the TurnOrder and CardLogicUI
        +TurnLogicUI(inputValidator: InputValidator, messages: ResourceBundle, numPlayers: int)
        ' PLAN: incorporate logic from printPlayerTurn into startTurn, if possible
        +startTurn(): void
        ' NOTE: promptForEndTurn was previously called checkIfTheyEndTurn
        -promptForTurnEnd(): boolean
        -endTurn(): boolean
        -checkIfGameOver(): boolean
        -endGame(): void
    }

    +class CardLogicUI {
        -{final} commandFactory: SimpleCardCommandFactory
        -{final} gameInvoker: GameInvoker
        -{final} inputValidator: InputValidator

        +CardLogicUI(commandFactory, gameInvoker, inputValidator)

        ' PLAN: playCard() will call the user for the desired inputs, take that input in
        ' PLAN: then, based on the CardType, will call the commandFactory's createCommand with
        ' PLAN: any necessary args, and then will call the invoker to execute that CommandType
        ' PLAN: The goal here is to abstract the need to have so many different card-specific 'play' methods
        +playCard(CardType card): void
        ' PLAN: will prompt the user for the desired inputs based on the card's InputType
        -promptPlayerForInputType(CardType card): void
    }
}
Main..>ui.GameUI
Main..>domain.GameLoader

GameUI-->java.ResourceBundle
GameUI-->domain.GameLoader
GameUI-->domain.GameType
GameUI..>ui.TurnLogicUI
GameUI-->java.Scanner

TurnLogicUI-->java.ResourceBundle
TurnLogicUI-->domain.TurnOrder
TurnLogicUI-->ui.CardLogicUI
CardLogicUI..>java.Scanner

CardLogicUI-->domain.SimpleCardCommandFactory
CardLogicUI-->domain.GameInvoker
CardLogicUI..>domain.CardType
CardLogicUI..>java.Scanner

'TODO: come back to these relationships for InputValidation and Scanner to best match design principles
InputValidator-->domain.GameType
GameUI..>ui.InputValidator
TurnLogicUI-->ui.InputValidator
CardLogicUI-->ui.InputValidator

package domain {
    ' ============================================================
    '         ABSTRACTIONS AND/OR ACCESSIBLE BY UI LAYER
    ' ============================================================
    +class GameLoader {
        -deck: Deck
        -turnOrder: TurnOrder
        -playerHands: Map<PlayerID, PlayerHand>

        +GameLoader()
        +setUpGame()
        -instantiateDeck()
        -instantiateTurnOrder()
        -instantiatePlayerHands()
    }

    +class GameInvoker {
        -commands: List<Command>

        +GameInvoker()
        +addCommand(command: Command): void
        +executeCommands(): void
    }

    +class SimpleCardCommandFactory {
        -deck: Deck
        -turnOrder: List<PlayerID>

        +CardCommandFactory()
        ' TODO: may need to adjust this if it's necessary to pass in the user input here (2 types of it: playerID vs int)
        ' TODO: will also need to look into if any cards require more than 1 type of input (which i believe they do)
        ' NOTE: getCommandForCardType will instantiate and return a Command corresponding to the CardType
        ' NOTE: there are less Commands than CardTypes because some share functionalities, like how CAT_ONE and CAT_TWO
        +getCommandForCardType(cardType: CardType, arguments): Command
        -getCommandForNoInputCard(cardType: CardType): Command
        -getCommandForPlayerInputCard(cardType: CardType, targetPlayer: PlayerID): Command
        -getCommandForIndexInputCard(cardType: CardType, targetIndex: int): Command
    }

    +interface Command {
        +execute(): void
        +undo(): void
    }

    ~abstract class ReversibleCommand {
        +execute(): void
        +undo(): void
    }

    ~abstract class IrreversibleCommand {
        +execute(): void
        +{final} undo(): void
    }

    note right of IrreversibleCommand
        The final undo() method in IrreversibleCommand would be a
        concrete method throwing an UnsupportedOperationException.
    end note

    ' ============================================================
    '          BEGINNING OF CONCRETE CARD COMMANDS
    ' ============================================================
    ~class ShuffleDeckCommand {
        -deck: Deck

        ~ShuffleDeckCommand(deck: Deck)
        ~execute(): void
    }

    ~class SeeTheFutureCommand {
        -deck: Deck
        -timesFive: boolean

        ' NOTE: if timesFive is true, then sees 5 cards into the future (expansion pack version)
        ' NOTE: if timeFives is false, then 3 cards into the future (original version)
        ~SeeTheFutureCommand(deck: Deck, timesFive: boolean)
        ~execute(): void
        ~undo(): void
    }

    ~class SwapTopAndBottomCardCommand {
        -deck: Deck

        ~SwapTopAndBottomCardCommand(deck: Deck)
        ~execute(): void
        ~undo(): void
    }

    ~class DefuseCommand {
        -playerHand: PlayerHand

        ~DefuseCommand(deck: Deck)
        ~execute(): void
    }

    ~class NopeCommand {
        ~NopeCommand()
        ~execute(): void
        ~undo(): void
    }

     ~class SkipTurnCommand {
        -turnOrder: TurnOrder
        -isSuper: boolean

        ~SkipTurnCommand(turnOrder: TurnOrder, isSuper: boolean)
        ~execute(): void
        ~undo(): void
    }

    ~class ReverseTurnOrderCommand {
        -turnOrder: List<PlayerID>

        ~SkipTurnCommand(turnOrder: List<PlayerID>)
        ~execute(): void
        ~undo(): void
    }

    ' PLAN: Utilize this class and GameInvoker list to implement attack stacking
    ' PLAN: and to replace the need for a manual attack queue
    ~class AttackPlayerCommand {
        -turnOrder: List<PlayerID>

        ~AttackCommand(turnOrder: List<PlayerID>)
        ~execute(): void
        ~undo(): void
    }

    ~class FlipImplodeFaceUpCommand {
        -deck: Deck

        ~FlipImplodeFaceUpCommand(deck: Deck)
        ~execute(): void
    }

    ~class ExplodeCommand {
        -playerHand: PlayerHand

        ~ExplodeCommand(playerHand: PlayerHand)
        ~execute(): void
    }

    ~class CursePlayerCommand {
        -targetPlayerHand: PlayerHand

        ~CursePlayerCommand(targetPlayerHand: PlayerHand)
        ~execute(): void
        ~undo(): void
    }

    ~class MarkCardCommand {
        -targetPlayerHand: PlayerHand

        ~MarkCardCommand(targetPlayerHand: PlayerHand)
        ~execute(): void
        ~undo(): void
    }

    ~class StealRandomCardCommand {
        -targetPlayerHand: PlayerHand

        ~StealRandomCardCommand(targetPlayerHand: PlayerHand)
        ~execute(): void
        ~undo(): void
    }

    ~class AddCardToHandCommand {
        -playerHand: PlayerHand

        ~AddCardToHandCommand(playerHand: PlayerHand)
        ~execute(): void
    }

    ~class RemoveCardFromHandCommand {
        -playerHand: PlayerHand

        ~RemoveCardFromCommand(playerHand: PlayerHand)
        ~execute(): void
    }

    ~class DrawTopCardCommand {
        -deck: Deck

        ~DrawTopCardCommand(deck: Deck)
        ~execute(): void
    }

    ~class DrawBottomCardCommand {
        -deck: Deck

        ~DrawBottomCardCommand(deck: Deck)
        ~execute(): void
    }

    ' ============================================================
    '                          RECEIVERS
    ' ============================================================

    +class PlayerHand {
        -playerID: PlayerID
        -hand: List<Card>
        -isDead: boolean
        -isCursed: boolean

        +PlayerHand()
        ~addCardToHand(card: Card): void
        ~removeCardFromHand(card: Card): void
        ~playGarbageCollection(card: Card): void
        ~stealRandomCardFromPlayer(targetPlayerHand: PlayerHand): void
        ~stealSpecificCardFromPlayer(cardType: CardType, targetPlayerHand: PlayerHand): void
        ~playMark(targetCardIndex: int, targetPlayerHand: PlayerHand): void
        ~playCursePlayer(playerID: Player): void
        ~playCursed(): void
        ~playCatomicBomb(): void
        ~playDefuse(): void
        ~playReinsertExplodingKitten(deckIndex: int): void
        ~playExplode(): void
        ~playFlipAndReinsertImplodingKitten(deckIndex: int): void
        ~playImplode(): void
        -setCursed(isCursed: boolean): void
        -getIndexOfCardType(cardType: CardType): int
        -checkIfPlayerDead(playerIndex: int): boolean
        -checkIfPlayerHasCard(playerIndex: int, cardType: CardType): boolean
        -checkPlayerHandEmpty(player: Player): boolean
    }

    +class TurnOrder {
        -numPlayers: int
        -activePlayer: PlayerID
        -turnOrder: List<PlayerID>
        -numTurnsPerPlayer: Map<PlayerID, Integer>
        -random: Random

        +TurnOrder(numPlayers: int)
        ~startTurn(): void
        ~playSkip(superSkip: boolean): int
        ~playReverseTurnOrder(): void
        ~playAttack(): void
        ~playTargetedAttack(targetPlayer): void
        -addToNumTurnsForPlayerID(playerID: PlayerID, numTurnsToAdd: int): void
        -subtractFromNumTurnsForPlayerID(playerID: PlayerID, numTurnsToSubstract: int): void
        -endTurn(): void
        -selectRandomPlayer(): PlayerID
    }

    +class Deck {
        -deck: List<Card>

        +Deck()
        ~drawCardFromTop(): Card
        ~drawCardFromBottom(): Card
        ~swapTopAndBottomCards(): void
        ~shuffleDeck(): void
        ~peekTopThreeCards(): List<Card>
        ~peekTopFiveCards(): List<Card>
        ~insertCardAtIndex(cardType: CardType, index: int): void
    }

    +class Card {
        -cardType: CardType
        -isMarked: boolean
        -isFaceUp: boolean

        +Card(cardType: CardType)
    }

    ' ============================================================
    '                           ENUMS
    ' ============================================================

    +enum CardType {
        NOPE,
        DEFUSE,
        ATTACK,
        SHUFFLE,
        SKIP,
        SEE_THE_FUTURE,
        CAT_ONE,
        CAT_TWO,
        CAT_THREE,
        CAT_FOUR,
        EXPLODING_KITTEN,
        STREAKING_KITTEN,
        SWAP_TOP_AND_BOTTOM,
        GARBAGE_COLLECTION,
        CURSE_OF_THE_CAT_BUTT,
        ALTER_THE_FUTURE,
        CATOMIC_BOMB,
        SUPER_SKIP,
        MARK,
        IMPLODING_KITTEN,
        REVERSE,
        FERAL_CAT,
        TARGETED_ATTACK,
        DRAW_FROM_THE_BOTTOM

        -{final} gameType: GameType
        -{final} inputType: InputType

        +CardType(gameType: GameType)
        +hasMatchingGameType(otherCardType: CardType): boolean
        +isInputType(inputType: InputType): boolean
    }

    +enum GameType {
        NONE,
        EXPLODING_KITTENS,
        STREAKING_KITTENS,
        IMPLODING_KITTENS
    }

    +enum InputType {
        NO_INPUT,
        PLAYER_ID_INPUT,
        INDEX_INPUT
    }

    +enum PlayerID {
        PLAYER_ONE,
        PLAYER_TWO,
        PLAYER_THREE,
        PLAYER_FOUR,
        PLAYER_FIVE
    }

    ' ============================================================
    '                      CLASS RELATIONSHIPS
    ' ============================================================
    GameLoader..>Deck

    GameInvoker-->"*"Command
    GameInvoker-->"*"PlayerHand

    ReversibleCommand..|>Command
    IrreversibleCommand..|>Command

    SimpleCardCommandFactory-->Deck
    SimpleCardCommandFactory-->"*"PlayerID
    SimpleCardCommandFactory..>Command

    ' TODO: Interfaces implemented by concrete commands
    ShuffleDeckCommand--|>ReversibleCommand
    SeeTheFutureCommand--|>ReversibleCommand
    SwapTopAndBottomCardCommand--|>ReversibleCommand
    DrawBottomCardCommand--|>IrreversibleCommand
    DrawTopCardCommand--|>IrreversibleCommand
    DefuseCommand--|>IrreversibleCommand
    NopeCommand--|>ReversibleCommand
    SkipTurnCommand--|>ReversibleCommand
    ReverseTurnOrderCommand--|>ReversibleCommand
    AttackPlayerCommand--|>ReversibleCommand
    FlipImplodeFaceUpCommand--|>IrreversibleCommand
    ExplodeCommand--|>IrreversibleCommand
    CursePlayerCommand--|>ReversibleCommand
    MarkCardCommand--|>ReversibleCommand
    StealRandomCardCommand--|>ReversibleCommand

    ' TODO: Concrete command instance variables
    StealRandomCardCommand-->PlayerHand
    MarkCardCommand-->PlayerHand
    CursePlayerCommand-->PlayerHand
    DrawTopCardCommand-->PlayerHand
    DrawBottomCardCommand-->PlayerHand

    AttackPlayerCommand-->TurnOrder
    SkipTurnCommand-->TurnOrder
    ReverseTurnOrderCommand-->TurnOrder

    ShuffleDeckCommand-->Deck
    StealRandomCardCommand-->Deck
    DefuseCommand-->Deck
    FlipImplodeFaceUpCommand-->Deck
    DrawBottomCardCommand-->Deck
    DrawTopCardCommand-->Deck

    Deck-u->"*"Card
    Deck..>CardType

    TurnOrder-->"*"PlayerID
    TurnOrder..>CardType

    PlayerHand-->PlayerID
    PlayerHand-->"*"Card
    PlayerHand..>CardType

    Card-->CardType
    CardType-->GameType
    CardType-->InputType
}

package java {
    +class Scanner {
    }

    +abstract class ResourceBundle {
    }

    +class Random {
    }
}

PlayerHand-->java.Random

@enduml