@startuml

' NEXT BIG STEPS:
' finish draft of general idea of domain classes and theirs vars
' draft how the UI class should be broken up into classes and vars
' add in the methods (and make sure accounting for all fields/functs of original design)
' make sure i've updated all the class relationships/arrows
' go over the design, focus on making it functional first basically
' then dive deeper into things like access modifiers, design principles, etc

package ui {
}

package domain {
    'TODO: go back through each class to look at access modifiers (plus each design principle)
    'TODO: look into best practices for naming classes in clean code/what verbs to avoid
    
    +class DeckActionLoader {
        -deck: Deck
    
        +DeckActionLoader()
        +setUpDeck()
        -instantiateDeck()
        -instantiateDeckActionCommands()
    }

    note top of DeckActionLoader
        DeckActionLoader will be responsible for instantiating
        the Deck and any concrete command classes.
    end note
    
    +class GameInvoker {
        -rand: Random
        -gameType: GameType
        -numPlayers: int

        'TODO: come back to eval whether want these here, i pulled these along for now cuz they were in OG Deck class
        'TODO: may want to move the exceptions to be local to functions instead? deps on if reused
        -maxDeckSize: int
        -instantiator: Instantiator
        -{static}{final} DECK_FULL_EXCEPTION: String
        -{static}{final} DRAW_FROM_EMPTY_DECK_EXCEPTION: String
        -{static}{final} NEGATIVE_INDEX_EXCEPTION: String
        -{static}{final} INDEX_GREATER_THAN_DECK_SIZE_EXCEPTION: String
        -{static}{final} MISMATCH_ORDER_SIZE_EXCEPTION: String
        -{static}{final} INDEX_OUT_OF_RANGE_EXCEPTION: String

        'TODO: update constructor args depending on relationship between UI and domain and whether GameInvoker should
        '      instantiate things itself
        +GameInvoker()
    }

    +interface DeckActionCommand {
        ' QUESTION: how do I let command only correspond to one of these functions? read further about command pattern
        +execute(): void
        +undo(): void
    }

    'TODO: can make other types of command for things like seeing into the future (but keeping simple for now)
    '      for example, PeekThreeCardsCommand, PeekFiveCardsCommand, ChangeFutureCardOrderCommand, ReverseTurnDirectionCommand, SkipTurnCommand, etc.
    +class ShuffleDeckCommand {
        -deck: Deck

        +ShuffleDeckCommand(Deck deck)
        +execute(): void
    }

    +class DefuseKittenCommand {
        -deck: Deck

        +DefuseKittenCommand(Deck deck)
        +execute(): void
        +undo(): void

    }

    note top of DefuseKittenCommand: Defuse cannot be 'Noped', so calling undo() would throw an exception.

    'TODO: come back to see how I can restrict access as much as possible for classes, esp Deck
    +class Deck {
        -deck: List<Card>

        +Deck()
        +executeActionCorrespondingToCardType(cardType: CardType)
        -shuffleDeck(): void
        -peekTopThreeCards(): List<Card>
        -peekTopFiveCards(): List<Card>
        -drawCardFromTop(): Card
        -drawCardFromBottom(): Card

        -insertCards(cardType: CardType, numberOfCards: int, bottom: boolean): void
        -insertExplodingKittenAtIndex(index: int): void
        -insertImplodingKittenAtIndex(index: int): void

        'TODO: add more methods here based on what actions deck needs to allow
    }

    note top of Deck: Deck is the receiver in Command Pattern

    +class Card {
        -cardType: CardType
        -isMarked: boolean

        +Card(cardType: CardType)
    }

    'TODO: add any other concrete card classes as needed here
    'QUESTION!!: cuz so many card types, do I want Card to instead just be CardType, with extra field that corresponds
    '          to command it returns?

    'TODO: figure out if I want the CardType enum still and if so, how to incorporate into the rest of my design?
    +enum CardType {
        NOPE,
        DEFUSE,
        ATTACK,
        SHUFFLE,
        SKIP,
        SEE_THE_FUTURE,
        CAT_ONE,
        CAT_TWO,
        CAT_THREE,
        CAT_FOUR,
        EXPLODING_KITTEN,
        STREAKING_KITTEN,
        SWAP_TOP_AND_BOTTOM,
        GARBAGE_COLLECTION,
        CURSE_OF_THE_CAT_BUTT,
        ALTER_THE_FUTURE,
        CATOMIC_BOMB,
        SUPER_SKIP,
        MARK,
        IMPLODING_KITTEN,
        REVERSE,
        FERAL_CAT,
        TARGETED_ATTACK,
        DRAW_FROM_THE_BOTTOM

        'TODO: figure out if I still want cards to have the GameType field
        -{final} gameType: GameType

        +CardType(gameType: GameType)
    }

    +enum GameType {
        'TODO: look into when GameType = NONE is used? is that just at the beginning during set up?
        NONE,
        EXPLODING_KITTENS,
        STREAKING_KITTENS,
        IMPLODING_KITTENS
    }

    note top of DeckActionCommand
        To avoid cluttering the diagram for the time being,
        I only included the concrete command classes that correspond
        to the 4 cards that I will be implementing during my refactoring.
    end note

    DeckActionLoader..>Deck
    DeckActionLoader..>ShuffleDeckCommand
    DeckActionLoader..>DefuseKittenCommand

    GameInvoker-->"*"DeckActionCommand

    ShuffleDeckCommand..|>DeckActionCommand
    ShuffleDeckCommand-->Deck

    Deck-u->"*"Card

    Card-->CardType
    CardType-->GameType
}

package java {
    +class Scanner {
    }

    +abstract class ResourceBundle {
    }

    +class Random {
    }
}

@enduml