@startuml

' TODO: go back in to add static and final

package ui {
    +class Main {
        +{static} main(String[] args): void
    }

    ~class GameStartUI {
        -messages: ResourceBundle
        -gameLoader: GameLoader
        -scanner: Scanner
        -input
        -numPlayers: int
        -gameType: GameType

        ~GameStartUI()
        ~startGame(): void
        -promptForLanguage(): void
        ' PLAN: instantiateGameDurationUI will first instantiate InputReader, prompting for player
        ' PLAN: number and game type, which it will then use to instantiate GameDurationUI
        -instantiateGameDurationUI(): GameDurationUI
    }

    ~class InputReader {
        -messages: ResourceBundle
        -scanner: Scanner
        -numPlayers: int
        -gameType: GameType

        +InputReader(scanner: Scanner, messages: ResourceBundle)
        ~promptForGameType(): GameType
        ~promptForNumberOfPlayers(): int
        ~promptForPlayerID(): PlayerID
        ~promptForCardIndex(): int
        ~promptForCardType(): CardType
        -playerIndexIsValid(): boolean
        -cardTypeIsValid(): boolean
    }

    ~class GameDurationUI {
        -{final} commandFactory: SimpleCardCommandFactory
        -{final} gameInvoker: GameInvoker
        -inputReader: InputReader
        -messages: ResourceBundle

        ' PLAN: GameDurationUI calls GameLoader to get commandFactory and gameInvoker
        ' PLAN: incorporate logic from printPlayerTurn into startTurn, if possible
        ~GameDurationUI(messages: ResourceBundle)
        ~runGameLoop(): void
        -promptForTurnStart(): void
        ' PLAN: playCard() will call the user for the desired inputs, take that input in
        ' PLAN: then, based on the CardType, will call the commandFactory's createCommand with
        ' PLAN: any necessary args, and then will call the invoker to execute that CommandType
        ' PLAN: The goal here is to abstract the need to have so many different card-specific 'play' methods
        -playCard(CardType card): void
        ' PLAN: will prompt the user for the desired inputs based on the card's InputType
        -promptPlayerForInputType(CardType card): void
        ' NOTE: promptForEndTurn was previously called checkIfTheyEndTurn
        -promptForTurnEnd(): boolean
        -endTurn(): void
        -checkIfGameOver(): boolean
        -endGame(): void
    }
}
Main..>ui.GameStartUI
Main..>domain.GameLoader
Main..>domain.GameInvoker
Main..>java.Scanner

GameStartUI-->java.ResourceBundle
GameStartUI-->domain.GameLoader
GameStartUI-->java.Scanner
GameStartUI-->domain.GameType
GameStartUI..>ui.GameDurationUI
GameStartUI..>ui.InputReader

GameDurationUI-->java.ResourceBundle
GameDurationUI-->ui.InputReader
GameDurationUI-->domain.SimpleCardCommandFactory
GameDurationUI-->domain.GameInvoker
GameDurationUI..>domain.CardType

InputReader-->java.ResourceBundle
InputReader-->java.Scanner
InputReader-->GameType

package domain {
    ' ============================================================
    '         ABSTRACTIONS AND/OR ACCESSIBLE BY UI LAYER
    ' ============================================================
    +class GameLoader {
        -deck: Deck
        -turnOrder: TurnOrder
        -playerHands: Map<PlayerID, PlayerHand>
        -{static}{final} commandFactory: SimpleCardCommandFactory
        -{static}{final} gameInvoker: GameInvoker

        +GameLoader(numPlayers: )
        +setUpGame(): void
        +{static} getCommandFactory(): SimpleCardCommandFactory
        +{static} getGameInvoker(): GameInvoker
        -instantiateDeck(): void
        -instantiateTurnOrder(): void
        -instantiatePlayerHands(): void
        -instantiateCommandFactory(): void
        -instantiateGameInvoker(): void
    }

    +class GameInvoker {
        -commandHistory: CommandHistory

        +GameInvoker()
        ' PLAN: executeCommand always calls commandHistory.addCommand()
        ' PLAN: and performs no action if a card is Noped
        +executeCommand(): void
    }

    ~class CommandHistory {
        ' PLAN: Nope Commands are not actually included in either List
        ' PLAN: Rather, Nope cards dictate how Commands move between the lists
        -commandsToDo: List<Command>
        -nopedCommands: List<Command>

        ~CommandHistory()
        ' PLAN: addCommand checks if the command is a NOPE command, and if so, calls either
        ' PLAN: undoLastCommand or redoLastCommand as appropriate (the latter representing)
        ' PLAN: "noping" a Nope
        ~addCommand(): void
        -undoLastCommand(): void
        -redoLastCommand(): void
    }

    +class SimpleCardCommandFactory {
        -deck: Deck
        -turnOrder: List<PlayerID>
        -playerHands: Map<PlayerID, PlayerHand>

        +CardCommandFactory()
        ' TODO: may need to adjust this if it's necessary to pass in the user input here (2 types of it: playerID vs int)
        ' TODO: will also need to look into if any cards require more than 1 type of input (which i believe they do)
        ' NOTE: getCommandForCardType will instantiate and return a Command corresponding to the CardType
        ' NOTE: there are less Commands than CardTypes because some share functionalities, like how CAT_ONE and CAT_TWO
        +getCommandForCardType(cardType: CardType, arguments): Command
        -getCommandForNoInputCard(cardType: CardType): Command
        -getCommandForPlayerInputCard(cardType: CardType, targetPlayer: PlayerID): Command
        -getCommandForIndexInputCard(cardType: CardType, targetIndex: int): Command
    }

    +interface Command {
        +execute(): void
        +undo(): void
    }

    ~abstract class ReversibleCommand {
        +execute(): void
        +undo(): void
    }

    ~abstract class IrreversibleCommand {
        +execute(): void
        +{final} undo(): void
    }

    note right of IrreversibleCommand
        The final undo() method in IrreversibleCommand would be a
        concrete method throwing an UnsupportedOperationException.
    end note

    ' ============================================================
    '          BEGINNING OF CONCRETE CARD COMMANDS
    ' ============================================================
    ~class ShuffleDeckCommand {
        -deck: Deck

        ~ShuffleDeckCommand(deck: Deck)
        ~execute(): void
    }

    ~class SeeTheFutureCommand {
        -deck: Deck
        -timesFive: boolean

        ' NOTE: if timesFive is true, then sees 5 cards into the future (expansion pack version)
        ' NOTE: if timeFives is false, then 3 cards into the future (original version)
        ~SeeTheFutureCommand(deck: Deck, timesFive: boolean)
        ~execute(): void
        ~undo(): void
    }

    ~class SwapTopAndBottomCardCommand {
        -deck: Deck

        ~SwapTopAndBottomCardCommand(deck: Deck)
        ~execute(): void
        ~undo(): void
    }

    ~class DefuseCommand {
        -playerHand: PlayerHand

        ~DefuseCommand(playerHand: PlayerHand)
        ~execute(): void
    }

    ~class NopeCommand {
        ~NopeCommand()
        ~execute(): void
        ~undo(): void
    }

     ~class SkipTurnCommand {
        -turnOrder: TurnOrder
        -isSuper: boolean

        ~SkipTurnCommand(turnOrder: TurnOrder, isSuper: boolean)
        ~execute(): void
        ~undo(): void
    }

    ~class ReverseTurnOrderCommand {
        -turnOrder: TurnOrder

        ~SkipTurnCommand(turnOrder: TurnOrder)
        ~execute(): void
        ~undo(): void
    }

    ' PLAN: Utilize this class and GameInvoker list to implement attack stacking
    ' PLAN: and to replace the need for a manual attack queue
    ~class AttackPlayerCommand {
        -turnOrder: TurnOrder

        ~AttackCommand(turnOrder: TurnOrder)
        ~execute(): void
        ~undo(): void
    }

    ~class AttackTargetedPlayerCommand {
        -turnOrder: TurnOrder
        -targetPlayerID: PlayerID

        ~AttackTargetedCommand(turnOrder: TurnOrder, targetPlayerID: PlayerID)
        ~execute(): void
        ~undo(): void
    }

    ~class FlipImplodeFaceUpCommand {
        -deck: Deck

        ~FlipImplodeFaceUpCommand(deck: Deck)
        ~execute(): void
    }

    ~class ExplodeCommand {
        -playerHand: PlayerHand
        -deck: Deck

        ~ExplodeCommand(playerHand: PlayerHand, deck: Deck)
        ~execute(): void
    }

    ~class CursePlayerCommand {
        -targetPlayerHand: PlayerHand

        ~CursePlayerCommand(targetPlayerHand: PlayerHand)
        ~execute(): void
        ~undo(): void
    }

    ~class MarkCardCommand {
        -targetPlayerHand: PlayerHand

        ~MarkCardCommand(targetPlayerHand: PlayerHand)
        ~execute(): void
        ~undo(): void
    }

    ~class StealRandomCardCommand {
        -sourcePlayerHand: PlayerHand
        -targetPlayerHand: PlayerHand

        ~StealRandomCardCommand(sourcePlayerHand: PlayerHand, targetPlayerHand: PlayerHand)
        ~execute(): void
        ~undo(): void
    }

    ~class AddCardTypeToHandCommand {
        -cardType: CardType
        -playerHand: PlayerHand

        ~AddCardTypeToHandCommand(cardType: CardType, playerHand: PlayerHand)
        ~execute(): void
    }

    ~class RemoveCardFromHandCommand {
        -cardIndex: int
        -playerHand: PlayerHand

        ~RemoveCardFromCommand(cardIndex: int, playerHand: PlayerHand)
        ~execute(): void
    }

    ~class DrawTopCardCommand {
        -playerHand: PlayerHand
        -deck: Deck

        ~DrawTopCardCommand(playerHand: PlayerHand, deck: Deck)
        ~execute(): void
    }

    ~class DrawBottomCardCommand {
        -playerHand: PlayerHand
        -deck: Deck

        ~DrawBottomCardCommand(playerHand: PlayerHand, deck: Deck)
        ~execute(): void
    }

    ' ============================================================
    '                          RECEIVERS
    ' ============================================================

    +class PlayerHand {
        -playerID: PlayerID
        -hand: List<Card>
        -isDead: boolean
        -isCursed: boolean

        +PlayerHand()
        ~addCardTypeToHand(cardType: CardType): void
        ~removeCardFromHand(card: Card): void
        ~playGarbageCollection(card: Card): void
        ~stealRandomCardFromPlayer(targetPlayerHand: PlayerHand): void
        ~stealSpecificCardFromPlayer(cardType: CardType, targetPlayerHand: PlayerHand): void
        ~playMark(targetCardIndex: int, targetPlayerHand: PlayerHand): void
        ~playCursePlayer(playerID: Player): void
        ~playCursed(): void
        ~playCatomicBomb(): void
        ~playDefuse(): void
        ~playReinsertExplodingKitten(deckIndex: int): void
        ~playExplode(): void
        ~playFlipAndReinsertImplodingKitten(deckIndex: int): void
        ~playImplode(): void
        -setCursed(isCursed: boolean): void
        -getIndexOfCardType(cardType: CardType): int
        -checkIfPlayerDead(playerIndex: int): boolean
        -checkIfPlayerHasCard(playerIndex: int, cardType: CardType): boolean
        -checkPlayerHandEmpty(player: Player): boolean
        -checkCardIndexWithinBounds(index: int): boolean
    }

    +class TurnOrder {
        -numPlayers: int
        -activePlayer: PlayerID
        -turnOrder: List<PlayerID>
        -numTurnsPerPlayer: Map<PlayerID, Integer>
        -random: Random

        +TurnOrder(numPlayers: int)
        ~startTurn(): void
        ~playSkip(superSkip: boolean): int
        ~playReverseTurnOrder(): void
        ~playAttack(): void
        ~playTargetedAttack(targetPlayer): void
        -addToNumTurnsForPlayerID(playerID: PlayerID, numTurnsToAdd: int): void
        -subtractFromNumTurnsForPlayerID(playerID: PlayerID, numTurnsToSubstract: int): void
        -endTurn(): void
        -selectRandomPlayer(): PlayerID
    }

    +class Deck {
        -deck: List<Card>

        +Deck()
        ~drawCardFromTop(): Card
        ~drawCardFromBottom(): Card
        ~swapTopAndBottomCards(): void
        ~shuffleDeck(): void
        ~peekTopThreeCards(): List<Card>
        ~peekTopFiveCards(): List<Card>
        ~insertCardAtIndex(cardType: CardType, index: int): void
        -checkCardIndexWithinBounds(index: int): boolean
    }

    +class Card {
        -cardType: CardType
        -isMarked: boolean
        -isFaceUp: boolean

        +Card(cardType: CardType)
    }

    ' ============================================================
    '                           ENUMS
    ' ============================================================

    +enum CardType {
        NOPE,
        DEFUSE,
        ATTACK,
        SHUFFLE,
        SKIP,
        SEE_THE_FUTURE,
        CAT_ONE,
        CAT_TWO,
        CAT_THREE,
        CAT_FOUR,
        EXPLODING_KITTEN,
        STREAKING_KITTEN,
        SWAP_TOP_AND_BOTTOM,
        GARBAGE_COLLECTION,
        CURSE_OF_THE_CAT_BUTT,
        ALTER_THE_FUTURE,
        CATOMIC_BOMB,
        SUPER_SKIP,
        MARK,
        IMPLODING_KITTEN,
        REVERSE,
        FERAL_CAT,
        TARGETED_ATTACK,
        DRAW_FROM_THE_BOTTOM

        -{final} gameType: GameType
        -{final} inputType: InputType

        +CardType(gameType: GameType)
        +hasMatchingGameType(otherCardType: CardType): boolean
        +isInputType(inputType: InputType): boolean
    }

    +enum GameType {
        NONE,
        EXPLODING_KITTENS,
        STREAKING_KITTENS,
        IMPLODING_KITTENS
    }

    +enum InputType {
        NO_INPUT,
        PLAYER_ID_INPUT,
        INDEX_INPUT,
        CARD_TYPE_INPUT
    }

    +enum PlayerID {
        PLAYER_ONE,
        PLAYER_TWO,
        PLAYER_THREE,
        PLAYER_FOUR,
        PLAYER_FIVE
    }

    ' ============================================================
    '                      CLASS RELATIONSHIPS
    ' ============================================================
    GameLoader..>Deck

    GameInvoker-->"*"Command

    ReversibleCommand..|>Command
    IrreversibleCommand..|>Command

    SimpleCardCommandFactory-->Deck
    SimpleCardCommandFactory-->"*"PlayerID
    SimpleCardCommandFactory..>Command

    ' Interfaces implemented by concrete commands
    ShuffleDeckCommand--|>ReversibleCommand
    SeeTheFutureCommand--|>ReversibleCommand
    SwapTopAndBottomCardCommand--|>ReversibleCommand
    DrawBottomCardCommand--|>IrreversibleCommand
    DrawTopCardCommand--|>IrreversibleCommand
    DefuseCommand--|>IrreversibleCommand
    NopeCommand--|>ReversibleCommand
    SkipTurnCommand--|>ReversibleCommand
    ReverseTurnOrderCommand--|>ReversibleCommand
    AttackPlayerCommand--|>ReversibleCommand
    AttackTargetedPlayerCommand--|>ReversibleCommand
    FlipImplodeFaceUpCommand--|>IrreversibleCommand
    ExplodeCommand--|>IrreversibleCommand
    CursePlayerCommand--|>ReversibleCommand
    MarkCardCommand--|>ReversibleCommand
    StealRandomCardCommand--|>ReversibleCommand
    AddCardTypeToHandCommand--|>IrreversibleCommand
    RemoveCardFromHandCommand--|>IrreversibleCommand

    ' Concrete command instance variables
    StealRandomCardCommand-->"*"PlayerHand
    MarkCardCommand-->PlayerHand
    CursePlayerCommand-->PlayerHand
    DrawTopCardCommand-->PlayerHand
    DrawBottomCardCommand-->PlayerHand
    ExplodeCommand-->PlayerHand
    AddCardTypeToHandCommand-->PlayerHand
    RemoveCardFromHandCommand-->PlayerHand
    DefuseCommand-->PlayerHand

    AttackPlayerCommand-->TurnOrder
    AttackTargetedPlayerCommand-->TurnOrder
    SkipTurnCommand-->TurnOrder
    ReverseTurnOrderCommand-->TurnOrder

    ExplodeCommand-->Deck
    ShuffleDeckCommand-->Deck
    StealRandomCardCommand-->Deck
    FlipImplodeFaceUpCommand-->Deck
    DrawBottomCardCommand-->Deck
    DrawTopCardCommand-->Deck
    SeeTheFutureCommand-->Deck
    SwapTopAndBottomCardCommand-->Deck

    AttackTargetedPlayerCommand-->PlayerID
    AddCardTypeToHandCommand-->CardType

    Deck-->"*"Card
    Deck..>CardType

    TurnOrder-->"*"PlayerID
    TurnOrder..>CardType

    PlayerHand-->PlayerID
    PlayerHand-->"*"Card
    PlayerHand..>CardType

    Card-->CardType
    CardType-->GameType
    CardType-->InputType
}

package java {
    +class Scanner {
    }

    +abstract class ResourceBundle {
    }

    +class Random {
    }
}

PlayerHand-->java.Random

@enduml