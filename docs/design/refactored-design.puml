@startuml

' NEXT BIG STEPS:
' finish draft of general idea of domain classes and theirs vars
' draft how the UI class should be broken up into classes and vars
' add in the methods (and make sure accounting for all fields/functs of original design)
' make sure i've updated all the class relationships/arrows
' go over the design, focus on making it functional first basically
' then dive deeper into things like access modifiers, design principles, etc

package ui {
}

package domain {
    +class DeckActionLoader {
        -deck: Deck

        +DeckActionLoader()
        +setUpDeck()
        -instantiateDeck()
        -instantiateDeckActionCommands()
    }

    note top of DeckActionLoader
        DeckActionLoader will be responsible for instantiating
        the Deck and any concrete command classes.
    end note

    +class GameInvoker {
        -rand: Random
        -gameType: GameType
        -numPlayers: int

        'TODO: come back to eval whether want these here, i pulled these along for now cuz they were in OG Deck class
        'TODO: may want to move the exceptions to be local to functions instead? deps on if reused
        -maxDeckSize: int
        -instantiator: Instantiator
        -{static}{final} DECK_FULL_EXCEPTION: String
        -{static}{final} DRAW_FROM_EMPTY_DECK_EXCEPTION: String
        -{static}{final} NEGATIVE_INDEX_EXCEPTION: String
        -{static}{final} INDEX_GREATER_THAN_DECK_SIZE_EXCEPTION: String
        -{static}{final} MISMATCH_ORDER_SIZE_EXCEPTION: String
        -{static}{final} INDEX_OUT_OF_RANGE_EXCEPTION: String

        'TODO: update constructor args depending on relationship between UI and domain and whether GameInvoker should
        '      instantiate things itself
        +GameInvoker()
    }

    interface Command {
        +execute(): void
    }

    +abstract class DeckActionCommand {
        +execute(): void
        +undo(): void
    }

    note top of DeckActionCommand
        I represented DeckActionCommand with an abstract class
        rather than an interface so that I can provide a default
        concrete implementation of the undo() method that does nothing
        because not all cards can be Nope'd (i.e. exploding kittens,
        defuse, etc.). However, any card that CAN be noped can
        simply override the undo() method.

        On a separate note, to avoid cluttering the diagram for the time being,
        I only included the concrete command classes that correspond
        to the 4 cards that I will be implementing during my refactoring.
    end note

    +class ShuffleDeckCommand {
        -deck: Deck

        +ShuffleDeckCommand(Deck deck)
        +execute(): void
        +undo(): void
    }

    +class DefuseCommand {
        -deck: Deck

        +DefuseCommand(Deck deck)
        +execute(): void
    }

    +class ExplodeCommand {
        +ExplodeCommand()
        +execute(): void
    }

    +class NopeCommand {
        +NopeCommand()
        +execute(): void
        +undo(): void
    }

    +abstract class TurnActionCommand {
        +execute()
    }

    +class PlayerHand {
        +playerID: PlayerID
        -hand: List<Card>

        +PlayerHand()

        -addCardToHand(card: Card): void
        -removeCardFromHand(playerIndex: int, cardType: CardType): void
        +getIndexOfCardFromHand(playerIndex: int, cardType: CardType): int

        +playDefuse(idxToInsertExplodingKitten: int, playerIndex: int): void
        +playCatomicBomb(): void
        +playReverse(): void
        +playSkip(superSkip: boolean): int
        +playGarbageCollection(cardToDiscard: CardType)
        +playMark(playerIndex: int, cardIndex: int): void
        +playTargetedAttack(attackedPlayerIndex: int): void
        'QUESTION: in what cases are the following two methods used, and do I need to keep them?
        +playExplodingKitten(playerIndex: int): boolean
        +playImplodingKitten(): void

        +stealRandomCardFromPlayer(player: Player): void
        +stealSpecificCardFromPlayer(cardType: CardType, player: PlayerID): void
        +attackPlayer(player: Player): void

        -checkPlayerHandEmpty(player: Player): boolean
        +checkIfPlayerDead(playerIndex: int): boolean
        +checkIfPlayerHasCard(playerIndex: int, cardType: CardType): boolean

        'MOVE ELSEWHERE: turn handling
'        +setNumberOfPlayers(numberOfPlayers: int): void
'        +retriveGameMode(gameType: GameType): void
'        +selectRandomPlayer(): PlayerID
'        +incrementPlayerTurn(): void
'        +setPlayerNumberOfTurns(): void
'        +getPlayerTurn(): int
'        +getNumberOfPlayers(): int
'        +checkNumberOfAlivePlayers(): int
'        +setCurrentPlayerNumberOfTurns(numberOfTurns: int): void
'        +decrementNumberOfTurns(): void
'        +getNumberOfTurns(): int
'        #setCurrentPlayerTurn(turn: int): void
'        -matchingGameType(gameType: GameType): boolean

        'MOVE ELSEWHERE: attack handling
'        +startAttackPhase(): void
'        +incrementAttackCounter(): void
'        +setAttackCounter(playerIndex: int): void
'        +addAttacks(): void
'        +addAttackQueue(attack: int): void
'        +removeAttackQueue(): int
'        +isAttackQueueEmpty(): boolean
'        +getAttacked(): boolean
'        +getAttackCounter(): int
'        +getNumberOfAttacks(): int
'        ~setNumberOfAttacks(numberOfAttacks: int): void
'        ~setAttacked(attacked: boolean): void
    }

    +class Deck {
        -deck: List<Card>

        +Deck()
        +executeActionCorrespondingToCardType(cardType: CardType)
        -shuffleDeck(): void
        -peekTopThreeCards(): List<Card>
        -peekTopFiveCards(): List<Card>
        -drawCardFromTop(): Card
        -drawCardFromBottom(): Card

        -insertCards(cardType: CardType, numberOfCards: int, bottom: boolean): void
        -insertExplodingKittenAtIndex(index: int): void
        -insertImplodingKittenAtIndex(index: int): void

        -swapTopAndBottomCards(): void
    }

    note top of Deck: Deck is the receiver in Command Pattern

    +class Card {
        -cardType: CardType
        -isMarked: boolean

        +Card(cardType: CardType)
    }

    +enum CardType {
        NOPE,
        DEFUSE,
        ATTACK,
        SHUFFLE,
        SKIP,
        SEE_THE_FUTURE,
        CAT_ONE,
        CAT_TWO,
        CAT_THREE,
        CAT_FOUR,
        EXPLODING_KITTEN,
        STREAKING_KITTEN,
        SWAP_TOP_AND_BOTTOM,
        GARBAGE_COLLECTION,
        CURSE_OF_THE_CAT_BUTT,
        ALTER_THE_FUTURE,
        CATOMIC_BOMB,
        SUPER_SKIP,
        MARK,
        IMPLODING_KITTEN,
        REVERSE,
        FERAL_CAT,
        TARGETED_ATTACK,
        DRAW_FROM_THE_BOTTOM

        -{final} gameType: GameType

        +CardType(gameType: GameType)
    }

    +enum GameType {
        'TODO: look into when GameType = NONE is used? is that just at the beginning during set up?
        NONE,
        EXPLODING_KITTENS,
        STREAKING_KITTENS,
        IMPLODING_KITTENS
    }

    +enum PlayerID {
        PLAYER_ONE,
        PLAYER_TWO,
        PLAYER_THREE,
        PLAYER_FOUR,
        PLAYER_FIVE
    }

    DeckActionLoader..>Deck
    DeckActionLoader..>ShuffleDeckCommand
    DeckActionLoader..>DefuseCommand
    DeckActionLoader..>ExplodeCommand
    DeckActionLoader..>NopeCommand

    GameInvoker-->"*"Command
    DeckActionCommand--|>Command
    TurnActionCommand--|>Command
    ShuffleDeckCommand..|>DeckActionCommand
    DefuseCommand..|>DeckActionCommand
    ExplodeCommand..|>DeckActionCommand
    NopeCommand..|>DeckActionCommand

    ShuffleDeckCommand-->Deck
    DefuseCommand-->Deck

    Deck-u->"*"Card
    Card-->CardType
    CardType-->GameType

    GameInvoker-->"*"PlayerHand
    PlayerHand-->PlayerID
}

package java {
    +class Scanner {
    }

    +abstract class ResourceBundle {
    }

    +class Random {
    }
}

@enduml