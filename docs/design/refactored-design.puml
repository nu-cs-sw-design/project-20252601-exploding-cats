@startuml

' NEXT BIG STEPS:
'TODO: update constructor args as needed
'TODO: add any instance variables each new class would need to fulfill functionality
' add in the methods (and make sure accounting for all fields/functs of original design)
' make sure i've updated all the class relationships/arrows
' go over the design, focus on making it functional first basically
' then dive deeper into things like access modifiers, design principles, etc

package ui {
    +class Main {
        +{static} main(String[] args): void
    }

    +class GameUI {
        -messages: ResourceBundle
        -gameType: GameType
        -numPlayers: numPlayers
        -gameLoader: GameLoader

        +GameUI()
        +promptForGameSetup(gameLoader: GameLoader): void
        -promptForLanguage(): void
        -promptForGameType(): void
        -promptForNumberOfPlayers(): int
        ' PLAN: GameUI will call GameLoader#setupGame() and will initialize any other necessary classes
        ' PLAN: to get the game started here, which will include passing in the ResourceBundle to other UI classes,
        ' PLAN: as well as passing in the game type and player number into domain-level classes
        ' PLAN: startGame will end with calling TurnLogicUI#startTurn
        +startGame(): void
    }

    ' TODO: maybe make InputValidator a singleton if it's beneficial? look into it
    +class InputValidator {
        -numPlayers: int
        -gameType: GameType

        +InputValidator(numPlayers: int)
        -checkValidPlayerIndexInput(): int
        -checkUserWithinBounds(userIndex: int): boolean
        -checkCardWithinBounds(cardIndex: int, player: Player): boolean
        -checkNegativeIndexDeck(indexToInsert: int): boolean
        -checkIfGreaterThanMaxIndexDeck(indexToInsert: int): boolean
        -checkCardIfInvalid(card: Card): boolean
    }

    +class TurnLogicUI {
        -inputValidator: InputValidator
        -messages: ResourceBundle
        -numPlayers: int
        -turnOrder: TurnOrder
        -CardLogicUI: CardLogicUI

        ' PLAN: TurnLogicUI instantiates the TurnOrder and CardLogicUI
        +TurnLogicUI(inputValidator: InputValidator, messages: ResourceBundle, numPlayers: int)
        ' PLAN: incorporate logic from printPlayerTurn into startTurn, if possible
        +startTurn(): void
        'NOTE: promptForEndTurn was previously called checkIfTheyEndTurn
        -promptForTurnEnd(): boolean
        -endTurn(): boolean
        -checkIfGameOver(): boolean
        -endGame(): void

        ' NOTE: leave this logic for domain classes
'        -checkIfNumberOfTurnsGreaterThanZero(): boolean
'        -checkIfNumberOfTurnsIsZero(): boolean
'        -checkIfCurrentPlayerTurn(playerIndex: int): boolean
    }

    +class CardLogicUI {
        -{final} commandFactory: SimpleCardCommandFactory
        -{final} gameInvoker: GameInvoker
        -{final} inputValidator: InputValidator

        +CardLogicUI(commandFactory, gameInvoker, inputValidator)

        ' PLAN: playCard() will call the user for the desired inputs, take that input in
        ' PLAN: then, based on the CardType, will call the commandFactory's createCommand with
        ' PLAN: any necessary args, and then will call the invoker to execute that CommandType
        ' PLAN: The goal here is to abstract the need to have so many different card-specific 'play' methods
        +playCard(CardType card): void
        ' PLAN: will prompt the user for the desired inputs based on the card's InputType
        -promptPlayerForInputType(CardType card): void

        ' TODO: remove all the following once I've determined that I've properly abstracted them
         ' Deck
'        -drawFromTheBottom(): void
'        -swapTopAndBottom(): void

        ' Playing cards
'        -playedCard(): int
'        -playAttack(targeted: boolean): void
'        -playGarbageCollection(): void
'        -playSpecialCombo(): int
'        -playNope(playerIndex: int): void
'        -playExplodingKitten(playerIndex: int): boolean
'        -playCurseOfTheCatButt(): void
'        -playSpecialComboTwoCards(cardType: CardType): void
'        -playMark(): void
'        -playCatomicBomb(): void
'        -playReverse(): void
'        -playSpecialComboThreeCards(cardType: CardType): void
'        -playSeeTheFuture(): void
'        -playShuffle(): void
'        -playSkip(superSkip: boolean): void
'        -playAlterTheFuture(): void
'        -playImplodingKitten(card: Card): boolean
'
'        ' Card action support
'        -startAttackFollowUp(targeted: boolean): void
'        -promptCursedMessage(): void

'        ' Validating specific card action prerequisites
'        -checkAllPlayersForNope(playerIndex: int): boolean
'        -checkIfCatCard(cardType: CardType): boolean
'        -checkNumberOfFeralCats(playerIndex: int): int
'        -checkIfPlayerIsAlive(userIndex: int): boolean
'        -checkIfPlayerIsCursed(player: Player): boolean
'        -checkReversed(): boolean
'        -checkIfCardMarked(playerIndex: int, cardIndex: int): boolean
'        -checkExplodingKitten(playerIndex: int): boolean
'        -checkFeralCat(numberOfFeralCatsToPlay: int, numberOfFeralCats: int, numberOfCatType: int, threshold: int): boolean
'        -checkAllPlayersNope(): boolean
    }
}
Main..>ui.GameUI
Main..>domain.GameLoader

GameUI-->java.ResourceBundle
GameUI-->domain.GameLoader
GameUI-->domain.GameType
GameUI..>ui.InputValidator
GameUI..>ui.TurnLogicUI

InputValidator-->domain.GameType

TurnLogicUI-->ui.InputValidator
TurnLogicUI-->java.ResourceBundle
TurnLogicUI-->domain.TurnOrder
TurnLogicUI-->ui.CardLogicUI

CardLogicUI-->CardLogicUI
CardLogicUI-->Deck
CardLogicUI-->SimpleCardCommandFactory
CardLogicUI-->GameInvoker
CardLogicUI-->InputValidator
CardLogicUI..>CardType

package domain {
    +class GameLoader {
        -deck: Deck

        +GameLoader()
        +setUpGame()
        -instantiateDeck()
        -instantiateDeckActionCommands()
        -instantiateTurnOrder()
        -instantiateTurnActionCommands()
    }

    +class GameInvoker {
        -commands: List<Command>

        +GameInvoker()
        +executeCommands(): void
    }

    interface Receiver {
        +executeActionCorrespondingToCardType(cardType: CardType)
    }

    +class TurnOrder {
        -numPlayers: int
        -activePlayer: PlayerID
        -turnOrder: List<PlayerID>

        +TurnOrder(numPlayers: int)
        +executeActionCorrespondingToCardType(cardType: CardType)
        -selectRandomPlayer(): PlayerID
        -incrementPlayerTurn(): void
        -decrementNumberOfTurns(): void
        -setCurrentPlayerTurn(turn: int): void
    }

    +class Deck {
        -deck: List<Card>

        +Deck()
        +executeActionCorrespondingToCardType(cardType: CardType)
        -drawCardFromTop(): Card
        -drawCardFromBottom(): Card
        -swapTopAndBottomCards(): void
        -shuffleDeck(): void
        -peekTopThreeCards(): List<Card>
        -peekTopFiveCards(): List<Card>
        -insertCards(cardType: CardType, numberOfCards: int, bottom: boolean): void
        -insertExplodingKittenAtIndex(index: int): void
        -insertImplodingKittenAtIndex(index: int): void
    }

    interface Command {
        +execute(): void
        +undo(): void
    }

    +class SimpleCardCommandFactory() {
        -deck: Deck
        -turnOrder: List<PlayerID>

        +CardCommandFactory()
        ' TODO: may need to adjust this if it's necessary to pass in the user input here (2 types of it: playerID vs int)
        ' TODO: will also need to look into if any cards require more than 1 type of input (which i believe they do)
        ' NOTE: getCommandForCardType will instantiate and return a Command corresponding to the CardType
        ' NOTE: there are less Commands than CardTypes because some share functionalities, like how CAT_ONE and CAT_TWO
        +getCommandForCardType(cardType: CardType, arguments): Command
        -getCommandForNoInputCard(cardType: CardType): Command
        -getCommandForPlayerInputCard(cardType: CardType, targetPlayer: PlayerID): Command
        -getCommandForIndexInputCard(cardType: CardType, targetIndex: int): Command
    }

    +abstract class DeckActionCommand {
        +execute(): void
        +undo(): void
    }

    note top of DeckActionCommand
        I represented DeckActionCommand with an abstract class
        rather than an interface so that I can provide a default
        concrete implementation of the undo() method that does nothing
        because not all cards can be Nope'd (i.e. exploding kittens,
        defuse, etc.). However, any card that CAN be noped can
        simply override the undo() method.

        On a separate note, to avoid cluttering the diagram for the time being,
        I only included the concrete command classes that correspond
        to the 4 cards that I will be implementing during my refactoring.
    end note

    +class ShuffleDeckCommand {
        -deck: Deck

        +ShuffleDeckCommand(deck: Deck)
        +execute(): void
    }

    +class SeeTheFutureCommand {
        -deck: Deck
        -timesFive: boolean

        ' NOTE: if timesFive is true, then sees 5 cards into the future (expansion pack version)
        ' NOTE: if timeFives is false, then 3 cards into the future (original version)
        +SeeTheFutureCommand(deck: Deck, timesFive: boolean)
        +execute(): void
        +undo(): void
    }

    +class SwapTopAndBottomCardCommand {
        -deck: Deck

        +SwapTopAndBottomCardCommand(deck: Deck)
        +execute(): void
        +undo(): void
    }

    +class DrawBottomCardCommand {
        -deck: Deck
        -playerHand: PlayerHand

        +DrawBottomCardCommand(deck: Deck, playerHand: PlayerHand)
        +execute(): void
        +undo(): void
    }

    +class DefuseCommand {
        -deck: Deck

        +DefuseCommand(deck: Deck)
        +execute(): void
    }

    +class ExplodeCommand {
        +ExplodeCommand()
        +execute(): void
    }

     +class ImplodeCommand {
        -playerHand: PlayerHand

        +ImplodeCommand()
        +execute(): void
}

    +class NopeCommand {
        +NopeCommand()

        +execute(): void
        +undo(): void
    }

    'TODO: may need to update this interface to allow for arguments (in which case won't share common Command interface)
    +abstract class TurnOrderCommand {
        +execute()
        +{final} undo(): void
    }

    note right of TurnOrderCommand
        The final undo() method in TurnOrderCommand would be a
        concrete method throwing an UnsupportedOperationException.
    end note

     +class SkipTurnCommand {
        -turnOrder: List<PlayerID>
        -isSuper: boolean

        +SkipTurnCommand(turnOrder: List<PlayerID>, isSuper: boolean)
        +execute(): void
        +undo(): void
    }

    +class ReverseTurnOrder {
        -turnOrder: List<PlayerID>

        +SkipTurnCommand(turnOrder: List<PlayerID>)
        +execute(): void
        +undo(): void
    }

    +class AttackPlayerCommand {
        -turnOrder: List<PlayerID>

        +AttackCommand(turnOrder: List<PlayerID>)
        +execute(): void
        +undo(): void
    }

    +abstract class TurnOrderCommand {
        +execute()
        +{final} undo(): void
    }

    ' TODO: go into the commands later to flesh out any args they need to be functional
    ' QUESTION: how accurate and functionally correct do I need to be with the specifics of each of these cards
    ' QUESTION: in my design, as I'm likely to miss some details since I didn't have to write use cases for all of these?
    +class CursePlayerCommand {
        -targetPlayer: playerID

        +CursePlayerCommand(targetPlayer: playerID)
        +execute(): void
        +undo(): void
    }

    +class MarkCardCommand {
        -targetPlayer: PlayerID
        -targetCardIndex: int

        ' TODO: if more secure, could also use CardType here instead of cardIndex and loop through targetPlayer's hand
        +MarkCardCommand(targetPlayer: playerID, targetCardIndex: int)
        +execute(): void
        +undo(): void
    }

    +class StealRandomCardCommand {
        -targetPlayer: PlayerID

        +StealRandomCardCommand(targetPlayer: playerID)
        +execute(): void
        +undo(): void
    }



    +class PlayerHand {
        +playerID: PlayerID
        -hand: List<Card>

        +PlayerHand()

        -addCardToHand(card: Card): void
        -removeCardFromHand(playerIndex: int, cardType: CardType): void
        +getIndexOfCardFromHand(playerIndex: int, cardType: CardType): int

        +playDefuse(idxToInsertExplodingKitten: int, playerIndex: int): void
        +playCatomicBomb(): void
        +playReverse(): void
        +playSkip(superSkip: boolean): int
        +playGarbageCollection(cardToDiscard: CardType)
        +playMark(playerIndex: int, cardIndex: int): void
        +playTargetedAttack(attackedPlayerIndex: int): void
        'QUESTION: in what cases are the following two methods used, and do I need to keep them?
        +playExplodingKitten(playerIndex: int): boolean
        +playImplodingKitten(): void

        +stealRandomCardFromPlayer(player: Player): void
        +stealSpecificCardFromPlayer(cardType: CardType, player: PlayerID): void
        +attackPlayer(player: Player): void

        -checkPlayerHandEmpty(player: Player): boolean
        +checkIfPlayerDead(playerIndex: int): boolean
        +checkIfPlayerHasCard(playerIndex: int, cardType: CardType): boolean


    }

    ' TODO: I moved attack logic into this class but I need to go back and
    ' TODO (continued): to figure out how to connect this / where to rest of design based on use cases
    +class AttackQueue() {
        -List<Integer> attackQueue;
        -int attackCounter;
        -int numberOfAttacks;
        -boolean attacked;

        +startAttackPhase(): void
        +incrementAttackCounter(): void
        +setAttackCounter(playerIndex: int): void
        +addAttacks(): void
        +addAttackQueue(attack: int): void
        +removeAttackQueue(): int
        +isAttackQueueEmpty(): boolean
        +getAttacked(): boolean
        +getAttackCounter(): int
        +getNumberOfAttacks(): int
        ~setNumberOfAttacks(numberOfAttacks: int): void
        ~setAttacked(attacked: boolean): void
    }

    +class Card {
        -cardType: CardType
        -isMarked: boolean

        +Card(cardType: CardType)
    }

    +enum CardType {
        NOPE,
        DEFUSE,
        ATTACK,
        SHUFFLE,
        SKIP,
        SEE_THE_FUTURE,
        CAT_ONE,
        CAT_TWO,
        CAT_THREE,
        CAT_FOUR,
        EXPLODING_KITTEN,
        STREAKING_KITTEN,
        SWAP_TOP_AND_BOTTOM,
        GARBAGE_COLLECTION,
        CURSE_OF_THE_CAT_BUTT,
        ALTER_THE_FUTURE,
        CATOMIC_BOMB,
        SUPER_SKIP,
        MARK,
        IMPLODING_KITTEN,
        REVERSE,
        FERAL_CAT,
        TARGETED_ATTACK,
        DRAW_FROM_THE_BOTTOM

        -{final} gameType: GameType
        -{final} inputType: InputType

        +CardType(gameType: GameType)
        +hasMatchingGameType(otherCardType: CardType): boolean
        +isInputType(inputType: InputType): boolean
    }

    +enum GameType {
        NONE,
        EXPLODING_KITTENS,
        STREAKING_KITTENS,
        IMPLODING_KITTENS
    }

    +enum InputType {
        NO_INPUT,
        PLAYER_ID_INPUT,
        INDEX_INPUT
    }

    +enum PlayerID {
        PLAYER_ONE,
        PLAYER_TWO,
        PLAYER_THREE,
        PLAYER_FOUR,
        PLAYER_FIVE
    }

    TurnOrder--|>Receiver
    Deck--|>Receiver

    GameLoader..>Deck
    GameLoader..>ShuffleDeckCommand
    GameLoader..>DefuseCommand
    GameLoader..>ExplodeCommand
    GameLoader..>NopeCommand

    GameInvoker-->"*"Command
    DeckActionCommand--|>Command
    TurnOrderCommand--|>Command
    ShuffleDeckCommand..|>DeckActionCommand
    DefuseCommand..|>DeckActionCommand
    ExplodeCommand..|>DeckActionCommand
    NopeCommand..|>DeckActionCommand

    NextTurnCommand..|>TurnOrderCommand
    SkipTurnCommand..|>TurnOrderCommand
    ForceTurnCommand..|>TurnOrderCommand

    ShuffleDeckCommand-->Deck
    DefuseCommand-->Deck

    Deck-u->"*"Card
    Card-->CardType
    CardType-->GameType

    GameInvoker-->"*"PlayerHand
    PlayerHand-->PlayerID
}

package java {
    +class Scanner {
    }

    +abstract class ResourceBundle {
    }

    +class Random {
    }
}

@enduml