@startuml

package presentation {
    +class Main {
        +{static} main(String[] args): void
    }

    ~class InputReader {
        -messages: ResourceBundle
        -{final} scanner: Scanner
        -numPlayers: int
        -gameType: GameType

        +InputReader(scanner: Scanner)
        ~promptAndSetLanguage(): void
        ~promptForNumPlayers(): int
        ~printStartTurn(activePlayerID: PlayerID, hand: List<Card)
        ~promptForPlayersWantsToEndTurn(): boolean
        ~printEndTurnConfirmation(): void
        ~printExplode(): void
        ~promptForWhereToInsertExplodingKittenAfterDefuse(): int
        ~printCardRequirementsNotMet(): void
        ~promptForCardIndexToPlay(activePlayerHandSize: int): int
        ~printCardDraw(drawnCardType: CardType)
        ~promptOtherPlayersForNope(activePlayers: List<PlayerID>, lastActorID: int): int
        ~printPlayShuffle(): void
        ~printEndGame(): void
        ~printNopeDuelResult(nopeCount: int): void
        ~promptForGameType(): GameType
        -indexWithinBounds(index: int, maxBound: int): boolean
    }

    ~class GameDurationUI {
        -{static}{final} reactiveCardTypes: List<CardType>
        -{final} commandFactory: SimpleCardCommandFactory
        -{final} gameInvoker: GameInvoker
        -{final} inputReader: InputReader
        -{final} gameModel: GameModel

        ~GameDurationUI(inputReader: InputReader, commandFactory: SimpleCardCommandFactory, gameInvoker: GameInvoker, gameModel: GameModel)
        ~runGameLoop(): void
        -promptForTurnStart(): void
        -playCardType(cardTypeToPlay: CardType, activePlayerID: PlayerID): void
        -enterNopeDuel(activePlayerID: PlayerID): void
        -endTurn(activePlayerID: PlayerID, activePlayerCards: List<Card>): void
        -gameIsOver(): boolean
    }
}

Main..>java.Scanner
Main..>InputReader
Main..>presentation.GameStartUI
Main..>domain.Deck
Main..>domain.GameLoader
Main..>domain.TurnOrder
Main..>"*"domain.PlayerID
Main..>"*"domain.PlayerHand
Main..>domain.SimpleCardCommandFactory
Main..>domain.GameInvoker
Main..>domain.GameModel

GameDurationUI-->presentation.InputReader
GameDurationUI-->domain.SimpleCardCommandFactory
GameDurationUI-->domain.GameInvoker
GameDurationUI-->domain.GameModel
GameDurationUI..>domain.CardType
GameDurationUI..>domain.Card
GameDurationUI..>domain.Command
GameDurationUI..>domain.PlayerID

InputReader-->java.ResourceBundle
InputReader-->java.Scanner
InputReader-->GameType
InputReader..>PlayerID
InputReader..>CardType
InputReader..>Card

package domain {
    ' ============================================================
    '         ABSTRACTIONS AND/OR ACCESSIBLE BY UI LAYER
    ' ============================================================
    +class GameLoader {
        -{final} numPlayers: int
        -{final} deck: Deck
        -playerHands: Map<PlayerID, PlayerHand>
        -{final} gameType: GameType

        +GameLoader(numPlayers: int, deck: Deck, gameType: GameType)
        +instantiatePlayerHands(): Map<PlayerID, PlayerHand>
        -populatePlayerHands(): void
    }

    +class GameModel {
        -{final} deck: Deck
        -{final} turnOrder: TurnOrder
        -{final} playerHands: Map<PlayerID, PlayerHand>

        +GameModel(deck: Deck, turnOrder: TurnORder, playerHands: Map<PlayerID, PlayerHand>
        +getCurrentPlayer(): PlayerID
        +getDeckSize(): int
        +getHandForPlayerID(playerID: PlayerID): List<Card>
        +drawCardForPlayerID(playerID: PlayerID): List<Card>
        +getOtherPlayersWithNopeCards(currentPlayer: PlayerID): List<PlayerID>
        +playerHasCardType(playerID: PlayerID, cardType: CardType): boolean
        +gameIsOver(): boolean
        +nextPlayerTurn(): void
    }

    +class GameInvoker {
        -{final} commandHistory: List<Command>
        -{final} nopedCommandHistory: List<Command>

        +GameInvoker()
        +addCommand(command: Command): void
        +executeCommands(): void
        -handleNope(): void
        -isNope(command: Command): boolean
    }

    +class SimpleCardCommandFactory {
        -{final} deck: Deck
        -{final} turnOrder: List<PlayerID>
        -{final} playerHands: Map<PlayerID, PlayerHand>

        +SimpleCardCommandFactory(deck: Deck, turnOrder: TurnOrder, hands: Map<PlayerID, PlayerHand>)
        +createCommandWithPlayerInput(cardType: CardType, currentPlayerID: PlayerID): Command
        +createCommandWithIndexInput(cardType: CardType, index: int): Command
        +createCommandWithPlayerAndIndexInput(cardType: CardType, player: PlayerID, index: int): Command
        +createTargetedCommand(cardType: CardType, currentPlayerID: PlayerID, targetPlayerID: PlayerID): Command
        +createTypeRequestCommand(actionCardType: CardType, currentPlayer: PlayerID, inputCardType: CardType): Command
    }

    +abstract class Command {
        #isIrreversible: boolean

        ~execute(): void
        ~isIrreversible(): boolean
    }

    ' ============================================================
    '          BEGINNING OF CONCRETE CARD COMMANDS
    ' ============================================================
    ~class ShuffleDeckCommand {
        -{final} deck: Deck
        -{final} playerHand: PlayerHand

        ~ShuffleDeckCommand(playerHand: PlayerHand, deck: Deck)
        ~execute(): void
    }

    ~class DefuseCommand {
        -{final} playerHand: PlayerHand

        ~DefuseCommand(playerHand: PlayerHand)
        ~execute(): void
    }

    ~class NopeCommand {
        -{final} playerHand: PlayerHand

        ~NopeCommand(playerHand: PlayerHand)
        ~execute(): void
    }

     ~class ExplodeCommand {
        -{final} turnOrder: TurnOrder

        ~ExplodeCommand(turnOrder: TurnOrder)
        ~execute(): void
    }

    ~class SeeTheFutureCommand {
        -{final} deck: Deck
        -{final} timesFive: boolean

        ' NOTE: if timesFive is true, then sees 5 cards into the future (expansion pack version)
        ' NOTE: if timeFives is false, then 3 cards into the future (original version)
        ~SeeTheFutureCommand(deck: Deck, timesFive: boolean)
        ~execute(): void
    }

    ~class SwapTopAndBottomCardCommand {
        -{final} deck: Deck

        ~SwapTopAndBottomCardCommand(deck: Deck)
        ~execute(): void
    }

     ~class SkipTurnCommand {
        -{final} turnOrder: TurnOrder
        -{final} isSuper: boolean

        ~SkipTurnCommand(turnOrder: TurnOrder, isSuper: boolean)
        ~execute(): void
    }

    ~class ReverseTurnOrderCommand {
        -{final} turnOrder: TurnOrder

        ~SkipTurnCommand(turnOrder: TurnOrder)
        ~execute(): void
    }

    ~class AttackPlayerCommand {
        -{final} turnOrder: TurnOrder

        ~AttackCommand(turnOrder: TurnOrder)
        ~execute(): void
    }

    ~class AttackTargetedPlayerCommand {
        -{final} turnOrder: TurnOrder
        -{final} targetPlayerID: PlayerID

        ~AttackTargetedCommand(turnOrder: TurnOrder, targetPlayerID: PlayerID)
        ~execute(): void
    }

    ~class FlipImplodeFaceUpCommand {
        -{final} deck: Deck

        ~FlipImplodeFaceUpCommand(deck: Deck)
        ~execute(): void
    }

    ~class CursePlayerCommand {
        -{final} targetPlayerHand: PlayerHand

        ~CursePlayerCommand(targetPlayerHand: PlayerHand)
        ~execute(): void
    }

    ~class MarkCardCommand {
        -{final} cardType: CardType
        -{final} targetPlayerHand: PlayerHand

        ~MarkCardCommand(targetCardType: CardType, targetPlayerHand: PlayerHand)
        ~execute(): void
    }

    ~class StealRandomCardCommand {
        -{final} sourcePlayerHand: PlayerHand
        -{final} targetPlayerHand: PlayerHand

        ~StealRandomCardCommand(sourcePlayerHand: PlayerHand, targetPlayerHand: PlayerHand)
        ~execute(): void
    }

    ~class CatomicBombCommand {
        -{final} deck: Deck
        -{final} turnOrder: TurnOrder

        ~CatomicBombCommand(deck: Deck, turnOrder: TurnOrder)
        ~execute(): void
    }

    ' ============================================================
    '                          RECEIVERS
    ' ============================================================

    +class PlayerHand {
        -{static}{final} NO_CARD_FOUND_EXCEPTION: String
        -{final} playerID: PlayerID
        -{final} hand: List<Card>
        -isDead: boolean
        -isCursed: boolean

        +PlayerHand(playerID: PlayerID)
        ~addCardToHand(card: Card): void
        ~removeCardTypeFromHand(cardType: CardType): void
        ~hasCardType(cardType: CardType): boolean
        ~getHand(): List<Card>
        -getIndexOfCardType(cardType: CardType): int
        ~playGarbageCollection(card: Card): void
        ~stealRandomCardFromPlayer(targetPlayerHand: PlayerHand): void
        ~stealSpecificCardFromPlayer(cardType: CardType, targetPlayerHand: PlayerHand): void
        ~playMark(targetCardIndex: int, targetPlayerHand: PlayerHand): void
        ~playCursePlayer(playerID: Player): void
        ~playCursed(): void
        ~playExplode(): void
        ~playImplode(): void
        -setCursed(isCursed: boolean): void
        -checkPlayerHandEmpty(player: Player): boolean
        -checkCardIndexWithinBounds(index: int): boolean
    }

    +class TurnOrder {
        -activePlayer: PlayerID
        -{final} turnOrder: List<PlayerID>

        +TurnOrder(numPlayers: int)
        ~playExplode(): void
        ~nextPlayerTurn(): void
        ~getCurrentPlayer(): PlayerID
        ~checkNumberOfAlivePlayers(): int
        ~playSkip(superSkip: boolean): int
        ~playReverseTurnOrder(): void
        ~playAttack(): void
        ~playTargetedAttack(targetPlayer): void
        -addToNumTurnsForPlayerID(playerID: PlayerID, numTurnsToAdd: int): void
        -subtractFromNumTurnsForPlayerID(playerID: PlayerID, numTurnsToSubstract: int): void
        -selectRandomPlayer(): PlayerID
    }

    +class Deck {
        -{static}{final} DRAW_FROM_EMPTY_DECK_EXCEPTION: String
        -{static}{final} NEGATIVE_INDEX_EXCEPTION: String
        -{static}{final} INDEX_GREATER_THAN_DECK_SIZE_EXCEPTION: String
        -{final} deck: List<Card>
        -{final} gameType: GameType
        -{final} numPlayers: int

        +Deck(gameType: GameType, numPlayers: int)
        ~removeExplodingKittens(): void
        ~reinsertExplodingKittens(): void
        ~insertCard(cardType: CardType, numberOfCards: int, bottom: boolean): void
        ~shuffleDeck(): void
        ~drawCard(): Card
        ~insertExplodingKittenAtIndex(indexToInsert: int): void
        ~getDeckSize(): int
        ~swapTopAndBottomCards(): void
        ~peekTopThreeCards(): List<Card>
        ~peekTopFiveCards(): List<Card>
        ~insertCardAtIndex(cardType: CardType, index: int): void
        ~shuffleAndPlaceExplodingKittensOnTop(): void
        ~flipAndReinsertImplodingKitten(deckIndex: int): void
        -checkCardIndexWithinBounds(index: int): boolean
    }

    +class Card {
        -{final} cardType: CardType
        -isMarked: boolean
        -isFaceUp: boolean

        +Card(cardType: CardType)
        +getCardType(): CardType
    }

    ' ============================================================
    '                           ENUMS
    ' ============================================================

    +enum CardType {
        NOPE,
        DEFUSE,
        ATTACK,
        SHUFFLE,
        SKIP,
        SEE_THE_FUTURE,
        CAT_ONE,
        CAT_TWO,
        CAT_THREE,
        CAT_FOUR,
        EXPLODING_KITTEN,
        STREAKING_KITTEN,
        SWAP_TOP_AND_BOTTOM,
        GARBAGE_COLLECTION,
        CURSE_OF_THE_CAT_BUTT,
        ALTER_THE_FUTURE,
        CATOMIC_BOMB,
        SUPER_SKIP,
        MARK,
        IMPLODING_KITTEN,
        REVERSE,
        FERAL_CAT,
        TARGETED_ATTACK,
        DRAW_FROM_THE_BOTTOM

        -{final} gameType: GameType

        +CardType(gameType: GameType)
        +hasMatchingGameType(otherCardType: CardType): boolean
    }

    +enum GameType {
        NONE,
        EXPLODING_KITTENS,
        STREAKING_KITTENS,
        IMPLODING_KITTENS
    }

    +enum PlayerID {
        PLAYER_ONE,
        PLAYER_TWO,
        PLAYER_THREE,
        PLAYER_FOUR,
        PLAYER_FIVE
    }

    ' ============================================================
    '                      CLASS RELATIONSHIPS
    ' ============================================================
    GameLoader-->Deck
    GameLoader-->TurnOrder
    GameLoader-->"*"PlayerHand
    GameLoader-->GameType
    GameLoader-->"*"PlayerID
    GameLoader-->SimpleCardCommandFactory
    GameLoader-->GameInvoker

    GameInvoker-->"*"Command

    ' TODO: see if can think of better way to structure reversability as a behavior while maintaining substituability
    ReversibleCommand..|>Command
    IrreversibleCommand..|>Command

    SimpleCardCommandFactory-->Deck
    SimpleCardCommandFactory-->"*"PlayerID
    SimpleCardCommandFactory..>Command

    ' Interfaces implemented by concrete commands
    ShuffleDeckCommand--|>ReversibleCommand
    SeeTheFutureCommand--|>ReversibleCommand
    SwapTopAndBottomCardCommand--|>ReversibleCommand
    DrawBottomCardCommand--|>IrreversibleCommand
    DrawTopCardCommand--|>IrreversibleCommand
    DefuseCommand--|>IrreversibleCommand
    NopeCommand--|>ReversibleCommand
    SkipTurnCommand--|>ReversibleCommand
    ReverseTurnOrderCommand--|>ReversibleCommand
    AttackPlayerCommand--|>ReversibleCommand
    AttackTargetedPlayerCommand--|>ReversibleCommand
    FlipImplodeFaceUpCommand--|>IrreversibleCommand
    ExplodeCommand--|>IrreversibleCommand
    CursePlayerCommand--|>ReversibleCommand
    MarkCardCommand--|>ReversibleCommand
    StealRandomCardCommand--|>ReversibleCommand
    AddCardTypeToHandCommand--|>IrreversibleCommand
    RemoveCardFromHandCommand--|>IrreversibleCommand
    CatomicBombCommand--|>ReversibleCommand

    ' Concrete command instance variables
    StealRandomCardCommand-->"*"PlayerHand
    MarkCardCommand-->PlayerHand
    CursePlayerCommand-->PlayerHand
    DrawTopCardCommand-->PlayerHand
    DrawBottomCardCommand-->PlayerHand
    ExplodeCommand-->PlayerHand
    AddCardTypeToHandCommand-->PlayerHand
    RemoveCardFromHandCommand-->PlayerHand
    DefuseCommand-->PlayerHand

    AttackPlayerCommand-->TurnOrder
    AttackTargetedPlayerCommand-->TurnOrder
    SkipTurnCommand-->TurnOrder
    ReverseTurnOrderCommand-->TurnOrder
    CatomicBombCommand-->TurnOrder

    ExplodeCommand-->Deck
    ShuffleDeckCommand-->Deck
    StealRandomCardCommand-->Deck
    FlipImplodeFaceUpCommand-->Deck
    DrawBottomCardCommand-->Deck
    DrawTopCardCommand-->Deck
    SeeTheFutureCommand-->Deck
    SwapTopAndBottomCardCommand-->Deck
    CatomicBombCommand-->Deck

    AttackTargetedPlayerCommand-->PlayerID
    AddCardTypeToHandCommand-->CardType

    Deck-->"*"Card
    Deck..>CardType

    TurnOrder-->"*"PlayerID
    TurnOrder..>CardType

    PlayerHand-->PlayerID
    PlayerHand-->"*"Card
    PlayerHand..>CardType

    Card-->CardType
    CardType-->GameType
    CardType-->InputType
}

package java {
    +class Scanner {
    }

    +abstract class ResourceBundle {
    }

    +class Random {
    }
}

PlayerHand-->java.Random

@enduml