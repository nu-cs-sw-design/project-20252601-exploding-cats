@startuml

' NEXT BIG STEPS:
' finish draft of general idea of domain classes and theirs vars
' draft how the UI class should be broken up into classes and vars
' add in the methods (and make sure accounting for all fields/functs of original design)
' make sure i've updated all the class relationships/arrows
' go over the design, focus on making it functional first basically
' then dive deeper into things like access modifiers, design principles, etc

'TODO: update constructor args as needed

package ui {
    +class Main {
        +{static} main(String[] args): void
    }

    'QUESTION: is there a way to abstract some of the card-specific logic to the domain layer?
    +class GameSetupUI() {
        'TODO: add any instance variables each new class would need to fulfill functionality
        +GameSetUp()
        +chooseLanguage(): void
        +chooseGame(): void
        +chooseNumberOfPlayers(): void
    }

    +class TurnLogicUI() {
        +GameLogic()

        +startTurn(): void
        -checkIfTheyEndTurn(): boolean
        -endTurn(): boolean
        +checkIfGameOver(): boolean
        +endGame(): void

        -printPlayerTurn(): void
        -checkIfNumberOfTurnsGreaterThanZero(): boolean
        -checkIfNumberOfTurnsIsZero(): boolean
        -checkIfCurrentPlayerTurn(playerIndex: int): boolean
    }

    +class InputValidation {
        +InputValidation()
        -checkValidPlayerIndexInput(): int
        -checkUserWithinBounds(userIndex: int): boolean
        -checkUserOutOfBounds(userIndex: int): boolean
        -checkCardWithinBounds(cardIndex: int, player: Player): boolean
        -checkCardWithinBoundsIndexed(cardIndex: int, player: Player): boolean
        -checkNegativeIndexDeck(indexToInsert: int): boolean
        -checkIfGreaterThanMaxIndexDeck(indexToInsert: int): boolean
        -checkCardIfInvalid(card: Card): boolean
    }

    'TODO: see if better to separate this close further into 2+ or not (weigh pros and cons)
    +class CardLogicUI() {
        +CardLogicUI()

        ' Deck
        -drawFromTheBottom(): void
        -swapTopAndBottom(): void

        ' Playing cards
        -playedCard(): int
        -playAttack(targeted: boolean): void
        -playGarbageCollection(): void
        -playSpecialCombo(): int
        -playNope(playerIndex: int): void
        -playExplodingKitten(playerIndex: int): boolean
        -playCurseOfTheCatButt(): void
        -playSpecialComboTwoCards(cardType: CardType): void
        -playMark(): void
        -playCatomicBomb(): void
        -playReverse(): void
        -playSpecialComboThreeCards(cardType: CardType): void
        -playSeeTheFuture(): void
        -playShuffle(): void
        -playSkip(superSkip: boolean): void
        -playAlterTheFuture(): void
        -playImplodingKitten(card: Card): boolean

        ' Card action support
        -startAttackFollowUp(targeted: boolean): void
        -promptCursedMessage(): void

        ' General prerequisite checking
        -hasCard(userIndex: int, cardType: CardType): boolean
        -hasCardDirect(player: Player, cardType: CardType): boolean
        -checkMatchingCardType(cardType: CardType, cardTypeTwo: CardType): boolean
        -checkIfDifferentCardType(cardType: CardType, cardTypeTwo: CardType): boolean
        -checkNumberOfCards(player: Player, cardType: CardType, threshold: int): boolean
        -matchingGameType(gameType: GameType): boolean

        ' Validating specific card action prerequisites
        -checkAllPlayersForNope(playerIndex: int): boolean
        -checkIfCatCard(cardType: CardType): boolean
        -checkNumberOfFeralCats(playerIndex: int): int
        -checkIfPlayerIsAlive(userIndex: int): boolean
        -checkIfPlayerIsCursed(player: Player): boolean
        -checkReversed(): boolean
        -checkIfCardMarked(playerIndex: int, cardIndex: int): boolean
        -checkExplodingKitten(playerIndex: int): boolean
        -checkFeralCat(numberOfFeralCatsToPlay: int, numberOfFeralCats: int, numberOfCatType: int, threshold: int): boolean
        -checkAllPlayersNope(): boolean
    }

    +class GameUI {
        -game: Game
        -messages: ResourceBundle
        -turnLogicUI: TurnLogicUI
        -inputValidator: InputValidation
        -cardLogicUI: CardLogicUI

        ' SET UP
        +GameUI(game: Game)

        ' GETTERS (commenting out for now to try to avoid needing getters)
        ' -getHandSize(playerIndex: int): int
        ' -getNumberOfPlayers(): int
        ' -getDeckSize(): int
        ' -getLocalizedCardType(cardType: CardType): String
    }



}

package domain {
    +class GameLoader {
        -deck: Deck

        +GameLoader()
        +setUpGame()
        -instantiateDeck()
        -instantiateDeckActionCommands()
        -instantiateTurnOrder()
        -instantiateTurnActionCommands()
    }

    +class GameInvoker {
        -commands: List<Command>

        +GameInvoker()
        +executeCommands(): void
    }

    interface Receiver {
        +executeActionCorrespondingToCardType(cardType: CardType)
    }

    +class TurnOrder {
        -numPlayers: int
        -activePlayer: PlayerID
        -turnOrder: List<PlayerID>

        +TurnOrder(numPlayers: int)
        +executeActionCorrespondingToCardType(cardType: CardType)
        -selectRandomPlayer(): PlayerID
        -incrementPlayerTurn(): void
        -decrementNumberOfTurns(): void
        -setCurrentPlayerTurn(turn: int): void
    }

    +class Deck {
        -deck: List<Card>

        +Deck()
        +executeActionCorrespondingToCardType(cardType: CardType)
        -drawCardFromTop(): Card
        -drawCardFromBottom(): Card
        -swapTopAndBottomCards(): void
        -shuffleDeck(): void
        -peekTopThreeCards(): List<Card>
        -peekTopFiveCards(): List<Card>
        -insertCards(cardType: CardType, numberOfCards: int, bottom: boolean): void
        -insertExplodingKittenAtIndex(index: int): void
        -insertImplodingKittenAtIndex(index: int): void
    }

    interface Command {
        +execute(): void
        +undo(): void
    }

    +abstract class DeckActionCommand {
        +execute(): void
        +undo(): void
    }

    note top of DeckActionCommand
        I represented DeckActionCommand with an abstract class
        rather than an interface so that I can provide a default
        concrete implementation of the undo() method that does nothing
        because not all cards can be Nope'd (i.e. exploding kittens,
        defuse, etc.). However, any card that CAN be noped can
        simply override the undo() method.

        On a separate note, to avoid cluttering the diagram for the time being,
        I only included the concrete command classes that correspond
        to the 4 cards that I will be implementing during my refactoring.
    end note

    +class ShuffleDeckCommand {
        -deck: Deck

        +ShuffleDeckCommand(Deck deck)
        +execute(): void
    }

    +class DefuseCommand {
        -deck: Deck

        +DefuseCommand(Deck deck)
        +execute(): void
    }

    +class ExplodeCommand {
        +ExplodeCommand()
        +execute(): void
    }

    +class NopeCommand {
        +NopeCommand()
        +execute(): void
        +undo(): void
    }

    'TODO: may need to update this interface to allow for arguments (in which case won't share common Command interface)
    +abstract class TurnActionCommand {
        +execute()
        +{final} undo(): void
    }

    note right of TurnActionCommand
        The final undo() method in TurnActionCommand would be a
        concrete method throwing an UnsupportedOperationException.
    end note

    +class NextTurnCommand {
        +execute()
    }

    +class SkipTurnCommand {
        +execute()
    }

    +class ForceTurnCommand {
        +execute()
    }

    +class PlayerHand {
        +playerID: PlayerID
        -hand: List<Card>

        +PlayerHand()

        -addCardToHand(card: Card): void
        -removeCardFromHand(playerIndex: int, cardType: CardType): void
        +getIndexOfCardFromHand(playerIndex: int, cardType: CardType): int

        +playDefuse(idxToInsertExplodingKitten: int, playerIndex: int): void
        +playCatomicBomb(): void
        +playReverse(): void
        +playSkip(superSkip: boolean): int
        +playGarbageCollection(cardToDiscard: CardType)
        +playMark(playerIndex: int, cardIndex: int): void
        +playTargetedAttack(attackedPlayerIndex: int): void
        'QUESTION: in what cases are the following two methods used, and do I need to keep them?
        +playExplodingKitten(playerIndex: int): boolean
        +playImplodingKitten(): void

        +stealRandomCardFromPlayer(player: Player): void
        +stealSpecificCardFromPlayer(cardType: CardType, player: PlayerID): void
        +attackPlayer(player: Player): void

        -checkPlayerHandEmpty(player: Player): boolean
        +checkIfPlayerDead(playerIndex: int): boolean
        +checkIfPlayerHasCard(playerIndex: int, cardType: CardType): boolean


    }

    ' TODO: I moved attack logic into this class but I need to go back and
    ' TODO (continued): to figure out how to connect this / where to rest of design based on use cases
    +class AttackQueue() {
        -List<Integer> attackQueue;
        -int attackCounter;
        -int numberOfAttacks;
        -boolean attacked;

        +startAttackPhase(): void
        +incrementAttackCounter(): void
        +setAttackCounter(playerIndex: int): void
        +addAttacks(): void
        +addAttackQueue(attack: int): void
        +removeAttackQueue(): int
        +isAttackQueueEmpty(): boolean
        +getAttacked(): boolean
        +getAttackCounter(): int
        +getNumberOfAttacks(): int
        ~setNumberOfAttacks(numberOfAttacks: int): void
        ~setAttacked(attacked: boolean): void
    }

    +class Card {
        -cardType: CardType
        -isMarked: boolean

        +Card(cardType: CardType)
    }

    +enum CardType {
        NOPE,
        DEFUSE,
        ATTACK,
        SHUFFLE,
        SKIP,
        SEE_THE_FUTURE,
        CAT_ONE,
        CAT_TWO,
        CAT_THREE,
        CAT_FOUR,
        EXPLODING_KITTEN,
        STREAKING_KITTEN,
        SWAP_TOP_AND_BOTTOM,
        GARBAGE_COLLECTION,
        CURSE_OF_THE_CAT_BUTT,
        ALTER_THE_FUTURE,
        CATOMIC_BOMB,
        SUPER_SKIP,
        MARK,
        IMPLODING_KITTEN,
        REVERSE,
        FERAL_CAT,
        TARGETED_ATTACK,
        DRAW_FROM_THE_BOTTOM

        -{final} gameType: GameType

        +CardType(gameType: GameType)
        +hasMatchingGameType(otherCardType: CardType): boolean
    }

    +enum GameType {
        NONE,
        EXPLODING_KITTENS,
        STREAKING_KITTENS,
        IMPLODING_KITTENS
    }

    +enum PlayerID {
        PLAYER_ONE,
        PLAYER_TWO,
        PLAYER_THREE,
        PLAYER_FOUR,
        PLAYER_FIVE
    }

    TurnOrder--|>Receiver
    Deck--|>Receiver

    GameLoader..>Deck
    GameLoader..>ShuffleDeckCommand
    GameLoader..>DefuseCommand
    GameLoader..>ExplodeCommand
    GameLoader..>NopeCommand

    GameInvoker-->"*"Command
    DeckActionCommand--|>Command
    TurnActionCommand--|>Command
    ShuffleDeckCommand..|>DeckActionCommand
    DefuseCommand..|>DeckActionCommand
    ExplodeCommand..|>DeckActionCommand
    NopeCommand..|>DeckActionCommand

    NextTurnCommand..|>TurnActionCommand
    SkipTurnCommand..|>TurnActionCommand
    ForceTurnCommand..|>TurnActionCommand

    ShuffleDeckCommand-->Deck
    DefuseCommand-->Deck

    Deck-u->"*"Card
    Card-->CardType
    CardType-->GameType

    GameInvoker-->"*"PlayerHand
    PlayerHand-->PlayerID
}

package java {
    +class Scanner {
    }

    +abstract class ResourceBundle {
    }

    +class Random {
    }
}

@enduml